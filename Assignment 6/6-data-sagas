<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/class/cs106b/build/_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Data Sagas</title>
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
   
    
    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Data Sagas</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<><style>
h4 {
    margin-top: 2rem;
}
</style>

<!-- This boilerplate inserts formatted due date -->

<!--  Boilerplate content for assignment index page -->

<h2 id="due-friday-february-26-at-1130-am-pacific">Due Friday, February 26 at 11:30 am Pacific</h2>

<ul>
  <li>Submissions received by due date receive a small <strong>on-time bonus</strong>.</li>
  <li>All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty.</li>
  <li>The <strong>grace period expires Sun, Feb 28 at 11:30 am Pacific</strong>, after which we cannot accept further late submissions.</li>
  <li>In this course, we express all date/times in <a href="https://www.timeanddate.com/worldclock/@5398563" title="Current time in Pacific">Pacific time GMT -8</a>. Our Paperless submission system also displays/records due dates and submission times in Pacific time.</li>
</ul>

<hr />

<p class="small">Parts of this assignment adapted from one by Julie Zelenski and Jerry Cain. <br />
Thanks to Michael Chang for his input on streaming top-k.</p>

<p>We’ve spent a lot of time talking about searching, sorting, and runtime complexity. This assignment is designed to give you a sense of how to combine those ideas together in the service of something larger: diving deep into data sets. Over the course of this assignment, you’ll build out a set of algorithms and data structures for processing large data sets. Once you’ve gotten them working, you’ll get to see them in action as they power four data analyses.</p>

<p><strong><em>You are welcome to work on this assignment in pairs.</em></strong></p>

<p>This assignment has three parts:</p>
<ul>
  <li><strong><em>Array Exploration</em></strong>: This debugging exercise is designed to get you comfortable exploring arrays in memory and seeing what lies beyond them.</li>
  <li><strong><em><code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code></em></strong>: This workhorse of a data structure is useful for finding the best objects of various types. It’s a powerful tool in its own right and can be used as a building block in other algorithms.</li>
  <li><strong><em>Streaming Top-k</em></strong>: A clever algorithm that finds the k best objects of a given type, and does so remarkably quickly.</li>
</ul>

<p>As usual, we suggest making slow and steady progress. Here’s our recommended timetable:</p>
<ul>
  <li>Aim to complete the debugging exercise within one day of this assignment going out.</li>
  <li>Aim to complete HeapPQueue within five days of this assignment going out.</li>
  <li>Aim to start Streaming Top-k within six days of this assignment going out.</li>
</ul>

<h2 id="problem-one-beyond-the-bounds-of-arrays">Problem One: Beyond the Bounds of Arrays</h2>

<p>The first part of this assignment deals with pointers and dynamic allocation, and that introduces some new types of errors you’ll need to learn to smoke out using the debugger. To get more familiar with what’s going on, we’re going to ask you to work the debugger to explore arrays and what you can find when you walk off the end of them.</p>

<p>Open the source file <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code>. That file contains a function named <code class="language-c++ highlighter-rouge"><span class="n">exploreArrays</span></code>. You’ll trace this function in the debugger. The reason we’d like you to explore this function is that we’d like you to see what arrays look like in memory in a controlled environment before you encounter memory issues “in the wild” (that is, when writing up your own code). It’s similar to how we wanted you to explore stack overflows in a simpler setting before turning you loose on writing your own recursive code.</p>

<h3 id="deliverables">Deliverables</h3>

<p>Here’s what you need to do.</p>

<ol class="keith-deliverables">
  <li>Set a breakpoint at the top of <code class="language-c++ highlighter-rouge"><span class="n">exploreArrays</span></code> in <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
  <li>Run the program with the debugger turned on, choose the “Explore Arrays” option from the top menu, then click “Go!” to trigger the breakpoint. Follow the instructions in <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code> and write your answers in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>.</li>
</ol>

<h2 id="problem-two-priority-queues-and-binary-heaps">Problem Two: Priority Queues and Binary Heaps</h2>

<h3 id="priority-queues">Priority Queues</h3>

<p>A <em>priority queue</em> is a modified queue in which elements are not dequeued in the order in which they were inserted. Instead, elements are removed from the queue in order of <em>priority</em>. For example, you could use a priority queue to model a hospital emergency room: patients enter in any order, but more critical patients are seen before less critical patients, regardless of how long the less-critical patients have been waiting. Similarly, if you were building a self-driving car that needed to process events, you might use a priority queue to respond to important messages (say, a pedestrian just walked in front of the car) before less important messages (say, a car switched on its turn signal).</p>

<p>For starters, here’s a refresher on the <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> type, which you first saw in Assignment 5:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">DataPoint</span> <span class="p">{</span>                                                             
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>   <span class="c1">// Name of this data point; varies by application           </span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>    <span class="c1">// "Weight" of this data point. Points are sorted by weight.</span>
<span class="p">};</span>                                                                             
</code></pre></div></div>

<p>Here’s the interface for the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type (we’ll explain the name in a minute):</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HeapPQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">HeapPQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">HeapPQueue</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">DataPoint</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">DataPoint</span> <span class="n">dequeue</span><span class="p">();</span>
    <span class="n">DataPoint</span> <span class="n">peek</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">printDebugInfo</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="cm">/* Up to you! */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Looking purely at the interface of this type, it sure looks like you’re dealing with a queue. You can enqueue elements, dequeue them, and peek at them. The difference between a priority queue and a regular queue is the order in which the elements are dequeued. In a regular <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>, elements are lined up in sequential order, and calling <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span><span class="p">()</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">peek</span><span class="p">()</span></code> gives back the element added the longest time ago. In the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>, the element that’s returned by <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span><span class="p">()</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">peek</span><span class="p">()</span></code> is the element that has the <strong><em>lowest weight</em></strong>. For example, let’s imagine we set up a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> like this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HeapPQueue</span> <span class="n">hpq</span><span class="p">;</span>                
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Amy"</span><span class="p">,</span>    <span class="mi">103</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Ashley"</span><span class="p">,</span> <span class="mi">101</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Anna"</span><span class="p">,</span>   <span class="mi">110</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Luna"</span><span class="p">,</span>   <span class="mi">161</span> <span class="p">});</span>
</code></pre></div></div>

<p>If we write</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DataPoint</span> <span class="n">data</span> <span class="o">=</span> <span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>     
</code></pre></div></div>

<p>then the string printed out will be <code class="language-c++ highlighter-rouge"><span class="n">Ashley</span></code>, since of the four elements enqueued, the weight associated with Ashley (101) was the lowest. Calling <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code> again will return <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Amy"</span><span class="p">,</span> <span class="mi">103</span><span class="p">}</span></code>, since her associated weight (103) was the lowest of what remains. Calling <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code> a third time would return <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Anna"</span><span class="p">,</span> <span class="mi">110</span><span class="p">}</span></code>.</p>

<p>Let’s insert more values. If we call <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span><span class="s">"Chioma"</span><span class="p">,</span> <span class="mi">103</span><span class="p">})</span></code> and then <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code>, the return value would be the newly-added <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Chioma"</span><span class="p">,</span> <span class="mi">103</span><span class="p">}</span></code> because her associated weight is lower than all others. And note that Chioma was the most-recently-added TA here; just goes to show you that this is quite different from a regular <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>!</p>

<h3 id="binary-heaps">Binary Heaps</h3>

<p>You’ll implement <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> using a data structure called a <strong><em>binary heap</em></strong>, hence the name <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. Binary heaps are best explained by example. Below is a binary heap containing a collection of current and former TAs, each of whom is associated with a number corresponding to the class that they TAed for.</p>

<p class="text-center"><img src="img/ta_heap.png" alt="A binary heap as described. At the top lies Ashley (who TA'd for 101). There are two branches, one going left and one going right; on the left, we have Kate (106), whose left and right children are Kali (108) and Julia (109), respectively. Kali has a single left child, Luna (161). Back to the top, to Ashley's right, we have Amy (103), whose left and right children are Anna (110) and Reynis (107), respectively." /></p>

<p>Let's look at the structure of this heap. Each value in the heap is stored in a <strong><em>node</em></strong>, and each node has zero, one, or two <strong><em>child nodes</em></strong> descending from it. For example, Ashley has two children (Kate and Amy) while Kali has just one child (Luna) and Julia has no children at all.</p>

<p>In a binary heap, we enforce the rule that <strong><em>every row of the heap, except for the last, must be full</em></strong>. That is, the first row should have one node, the second row two nodes, the third row four nodes, the fourth row eight nodes, etc., up until the last row. Additionally, that last row must be filled from the left to the right. You can see this in the above example – the first three rows are all filled in, and only the last row is partially filled. Here are two other examples of binary heaps, each of which obey this rule:</p>

<div style="display: flex; align-items: center; justify-items: center">
  <p class="m-3"><img src="img/planet_heap.png" alt="A binary heap of the names of the planets, where the radius of the planet is its priority. Mercury sits at the top, with Neptune and Mars being its children. Neptune has Jupiter and Uranus as its children. Mars has Saturn and Venus as its children. Every row of the heap is filled." /></p>

  <p class="m-3"><img src="img/name_heap.png" alt="A binary heap with various names, where the priority is their birth year. Jackie is on top, with Jermaine and Tito as their children. Jermain has Michael and Marlon as children. Tito has no children. The top two rows of the heap are full; the last one is partially filled (two of four; Jeramine has two children, while Tito has none)" /></p>
</div>

<p>We also enforce one more property – <strong><em>no child node’s weight is less than its parent’s weight</em></strong>. All three of the heaps you've seen so far obey this rule. However, there are no guarantees about how nodes can be ordered within a row; as you can see from the examples, within a row the ordering is pretty much arbitrary.</p>

<p class="text-center">To recap, here are the three rules for binary heaps:</p>
<div style="display: flex; justify-content: center">
  <ul>
    <li>Every node in a binary tree has either zero, one, or two children.</li>
    <li>No child’s weight is less than the weight of its parent.</li>
    <li>Every row of the heap, except the last, is completely full, and the last row’s elements are as far to the left as possible.</li>
  </ul>
</div>

<p>Before moving on, edit the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code> with answers to the following question.</p>

<div class="keith-deliverables">
  <p>Q3: Draw three different binary heaps containing the DataPoints given in the example on the right-hand side above (the one containing Jackie, Jermaine, etc.) Yes, we know that we’re asking you to draw pictures in a text file. Here’s an example of what that could look like:</p>
  <pre><code class="language-plain">          Person A
           Weight
        /        \
    Person B    Person C
     Weight      Weight
    /        \
Person D    Person E
 Weight      Weight    
</code></pre>
  <p>Maya Ziv, section leader extraordinaire, suggests using <a href="http://asciiflow.com/">this website</a> to draw the binary heaps.</p>
</div>

<h4 id="binary-heap-enqueue-bubble-up">Binary Heap Enqueue ("Bubble-up")</h4>

<p>It is easy to read off which element has the smallest weight in a binary heap – it's the one at the top. It is also efficient to insert an element into a binary heap. Suppose, for example, that we have this binary heap containing some famous satellites:</p>

<p class="text-center"><img src="img/satellite_enqueue_1.png" alt="A binary heap showing famous satellites, with their associated priority being the year in which it was launched. The satellites are written in the language native to the country they're from. At the top is Sputnik (1957), with its left child being Aryabhata (1975) and right child being Ohsumi (1970). Aryabhata also has two children, Ofeq (1988) and Sina (2005)." /></p>

<p>Let's add the San Marco, the first Italian satellite, to this heap with weight 1964. Since a binary heap has all rows except the last filled, the only place we can initially place San Marco is in the first available spot in the last row. This is as the left child of Japan’s first space probe 大隅, so we place the new node for San Marco there:</p>

<p class="text-center"><img src="img/satellite_enqueue_2.png" alt="The heap above has been modified to include San Marco (1964) as the left child of Ohsumi (1970)" /></p>

<p>At this point, the binary heap is invalid because San Marco’s weight (1964) is less than that of 大隅 (1970). To fix this, we run a <strong><em>bubble-up</em></strong> step and continuously swap San Marco with its parent node until its weight is at least that of its parent’s. This means that we exchange San Marco and 大隅, shown here:</p>

<p class="text-center"><img src="img/satellite_enqueue_3.png" alt="The heap above has been modified to swap the positions of San Marco (1964) and Ohsumi (1970); now, the right child of Sputnik (1957) is San Marco (1964), and San Marco's left child is Ohsumi (1970)" /></p>

<p>Since San Marco’s weight (1964) is greater than its parent’s weight (1957), it’s now in the right place, and we’re done. We now have a binary heap containing all of the original values, plus San Marco.</p>

<p>Let's suppose that we now want to insert Explorer, the first US space probe, into the heap with weight 1958. We begin by placing it at the next free location in the last row, as the right child of San Marco:</p>

<p class="text-center"><img src="img/satellite_enqueue_4.png" alt="The heap above has been modified to add Explorer (1958) as the right child of San Marco." /></p>

<p>We then bubble Explorer up one level to fix the heap:</p>

<p class="text-center"><img src="img/satellite_enqueue_5.png" alt="The heap above has been modified to swap the positions of San Marco (1964) and Explorer (1958)" /></p>

<p>And, again, have a new heap containing these elements. As a final example, suppose that we want to insert 东方红, the first Chinese space probe, into this heap with weight 1970. We begin by putting it into the first free spot in the last row, which in this case is as the left child of the Israeli satellite אופק:</p>

<p class="text-center"><img src="img/satellite_enqueue_6.png" alt="The heap above, modified to insert Dong Fang Hong (1970) as the left child of Ofeq (1988). The heap is now four rows high (as the third row was filled by adding Explorer)." /></p>

<p>We now do a bubble-up step. We first swap 东方红 and אופק to get:</p>

<p class="text-center"><img src="img/satellite_enqueue_7.png" alt="The heap above has been modified to swap the positions of Dong Fang Hong (1970) and Ofeq (1988)" /></p>

<p>Notice that 东方红’s weight is still less than its new parent’s weight, so it’s not yet in the right place. We therefore do another swap, this time with the Indian satellite आर्यभट, to get</p>

<p class="text-center"><img src="img/satellite_enqueue_8.png" alt="The heap above has been modified to swap the positions of Dong Fang Hong (1970) and Aryabhata (1975)" /></p>

<p>This step runs very quickly. With a bit of math we can show that if there are n nodes in a binary heap, then the height of the heap is at most O(log n), and so we need at most O(log n) swaps to put the new element into its proper place. Thus the enqueue step runs in time O(log n). That’s pretty fast! Remember that the base-2 logarithm of a million is about twenty, so even with a million elements we’d only need about twenty swaps to place things!</p>

<p>Before moving on, answer the following question in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>:</p>

<div class="keith-deliverables">
  <p>Q4: Draw the binary heap formed by inserting these nine DataPoints into an empty binary heap using the algorithm described above. Specifically, insert those data points in the order that’s shown below. You only need to show your final answer, not your intermediate steps.</p>
  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="s">"R"</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"A"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"B"</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"K"</span><span class="p">,</span> <span class="mi">7</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"G"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"V"</span><span class="p">,</span> <span class="mi">9</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"T"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"O"</span><span class="p">,</span> <span class="mi">8</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"S"</span><span class="p">,</span> <span class="mi">6</span> <span class="p">}</span>
</code></pre></div>  </div>
  <p>There are many binary heaps you can form that contain these elements, but only one of them will be what you get by tracing the algorithm.</p>
</div>

<h4 id="binary-heap-dequeue-bubble-down">Binary Heap Dequeue ("Bubble-down")</h4>

<p>We now know how to insert an element into a binary heap. How do we implement dequeue? We know that the minimum-weight element of the binary heap is atop the heap, but we can't just remove it – that would break the heap into two smaller heaps. Instead, we use a more clever algorithm. First, we swap the top of the heap, the original Soviet satellite Спутник, with the rightmost node in the bottom row of the heap (אופק) as shown here:</p>

<p class="text-center"><img src="img/satellite_dequeue_1.png" alt="The same heap as before, except now Ofeq (1988) is at the root, and Sputnik (1957) is at the bottommost element of the heap (where Ofeq once was)." /></p>

<p>Now, we can remove Спутник from the heap, which is the element we’ll return. We now have this:</p>

<p class="text-center"><img src="img/satellite_dequeue_2.png" alt="The same heap as before, but Sputnik (1957) is removed. The heap now looks like this: Ofeq (1988) at the top, with Dong Fang Hong (1970) and Explorer (1958) its left and right children. Dong Fang Hong (1970) has Aryabhata (1975) and Sina (2005) as its left and right children. Explorer (1958) has Ohsumi (1970) and San Marco (1964) as its left and right children." /></p>

<p>Unfortunately, what we are left with isn’t a binary heap because the top element (אופק) is one of the highest-weight values in the heap. To fix this, we will use a <strong><em>bubble-down</em></strong> step and repeatedly swap אופק with its <strong><em>lower-weight</em></strong> child until it comes to rest. First, we swap אופק with Explorer to get this heap:</p>

<p class="text-center"><img src="img/satellite_dequeue_3.png" alt="The same heap as before, but Explorer and Ofeq swap so Explorer is now the root of the tree." /></p>

<p>Since אופק is not at rest yet, we swap it with the smaller of its two children (San Marco) to get this:</p>

<p class="text-center"><img src="img/satellite_dequeue_4.png" alt="The same heap as before, but San Marco and Ofeq swap." /></p>

<p>And we're done. That was fast! As with enqueue, this step runs in time O(log n), because we make at most O(log n) swaps. This means that enqueuing n elements into a binary heap and then dequeuing them takes time at most O(n log n). This method of sorting values is called <em>heapsort</em>.</p>

<p>To confirm that this makes sense, answer this question in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>:</p>

<p class="keith-deliverables">Q5: Draw the binary heap that results from following this <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> procedure on the heap you drew in Q4 of this problem.</p>

<h4 id="binary-heaps-as-arrays">Binary Heaps As Arrays</h4>

<p>How do we represent a binary heap in code? Amazingly, we can implement the binary heap using nothing more than a dynamic array. “An array‽,” you might exclaim. “How is it possible to store that complicated heap structure inside an array‽” The key idea is to number the nodes in the heap from top-to-bottom, left-to-right. For example, we might number the nodes of the previous heap like this:</p>

<p class="text-center"><img src="img/satellite_array_heap_1.png" alt="The same heap as before. Explorer is at the top labelled &quot;1&quot;. Its left and right children, Dong Fang Hong and San Marco, are labelled 2 and 3. Dong Fang Hong's children, Aryabhata and Sina, are labelled 4 and 5. San Marco's children, Ohsumi and Ofeq, are labelled 6 and 7." /></p>

<p>This numbering system has some amazing properties:</p>
<ul>
  <li>Given a node numbered n, its children (if any) are numbered 2n and 2n + 1.</li>
  <li>Given a node numbered n, its parent is numbered n / 2, rounded down.</li>
</ul>

<p>You can check this yourself in the above tree. That's pretty cool, isn't it? The reason that this works is that the heap has a rigid shape – every row must be filled in completely before we start adding any new rows. Without this restriction, our numbering system wouldn't work.</p>

<p>Because our algorithms on binary heaps only require us to navigate from parent to child or child to parent, it's possible to represent binary heap using just an array. Each element will be stored at the index given by the above numbering system. Given an element, we can then do simple arithmetic to determine the indices of its parent or its children. For example, we’d encode the above heap as the following array:</p>

<p class="text-center"><img src="img/satellite_array_heap_2.png" alt="The same heap as before, with the above numbering system translated to an array that reads, from index 1 to 7: Explorer, Dong Fang Hong, San Marco, Aryabhata, Sina, Ohsumi, Ofeq" /></p>

<p>The enqueue and dequeue algorithms we have developed for binary heaps translate beautifully into algorithms on the array representation. For example, suppose we want to insert Astérix, the first French satellite, into this binary heap with weight 1965. We begin by adding it into the heap, as shown here:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_1.png" alt="The same heap as before, with Astérix inserted in the bottom left (the left child of Aryabhata). The array now has eight slots, and Astérix is inserted into the new eighth slot." /></p>

<p>Notice that Astérix is at index 8, which is the last position in the array. This is not a coincidence; whenever you add a node to a binary heap, it always goes at the end of the array. (Do you see why?)</p>

<p>We then bubble Astérix up into its final position by repeatedly comparing it to its parent. Since Astérix is at position 8, its parent (आर्यभट) is at position 4. Since Astérix precedes आर्यभट, we swap them:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_2.png" alt="The same heap as before, but Aryabhata and Astérix have switched (Astérix bubbling up to take Aryabhata's place). Similarly, in the array, Aryabhata (now at position 8) and Astérix (now at position 4) swapped places." /></p>

<p>Astérix’s parent is now at position 2 (东方红), so we swap Astérix and 东方红 to get the final heap:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_3.png" alt="The same heap as before, but Dong Fang Hong and Astérix have switched (Astérix bubbling up to take Dong Fang Hong's place). Similarly, in the array, Dong Fang Hong (now at position 4) and Astérix (now at position 2) swapped places." /></p>

<p>To confirm that this all makes sense, answer the following question in ShortAnswers.txt:</p>

<p class="keith-deliverables">Q6: Draw the array representation of the binary heap that you drew in Q5.</p>

<h3 id="deliverables-1">Deliverables</h3>

<p>Now, let’s talk about the coding assignment.</p>

<p>Your task is to implement this data structure to power the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type. Although in practice you would layer this class on top of the Vector, for the purposes of this assignment <strong><em>you must do all of your own memory management</em></strong>. This means that you must dynamically allocate and deallocate the underlying array in which your heap is represented.</p>

<p>Here is our recommendation for how to complete this part of the assignment.</p>

<ol class="keith-deliverables">
  <li>Start off by adding any private member variables you’ll need to <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>. You know you’ll at a bare minimum need to define something to hold the elements in the heap. We recommend you start there, since without adding member variables you won’t be able to store anything.</li>
  <li>Implement the constructor in a way that allocates an initial amount of space for the elements of the heap. We recommend picking a medium-sized array to begin with (say, around size 100), though you’ll probably drop that to something lower later on. Then, implement <code class="language-c++ highlighter-rouge"><span class="n">size</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code>, which should each probably be a single line long.</li>
  <li>To test whether your code works correctly, choose the “Interactive PQueue” option from the top menu bar. This will let you create and issue commands to a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> using a graphical interface. Confirm that you can create a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> and that <code class="language-c++ highlighter-rouge"><span class="n">size</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code> behave as expected (<code class="language-c++ highlighter-rouge"><span class="n">size</span></code> should return <code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code> should return <code class="language-c++ highlighter-rouge"><span class="nb">true</span></code>).</li>
  <li>Implement <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> using the bubble-up algorithm. Then, implement <code class="language-c++ highlighter-rouge"><span class="n">printDebugInfo</span></code> in a way that will let you confirm that your code works correctly. For now, don’t worry about what happens if you run out of space in your dynamic array; you’ll patch this up later. Head back to the Interactive PQueue option and test out your <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> code by enqueuing a bunch of values, working out with a pencil and paper what the array contents should look like, and then using <code class="language-c++ highlighter-rouge"><span class="n">printDebugInfo</span></code> to confirm things work.</li>
  <li>Implement <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> using the bubble-down algorithm. Run some initial tests using the Interactive PQueue feature and a pencil and paper, as before. Once that seems to be working, run the full automated test suite and see what happens. If you’re passing all the tests, except for the tests that require your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> to hold thousands of elements and the ones that check for memory leaks, move on to the next step. Otherwise, iterate and debug until things are working.</li>
  <li>Change your implementation of enqueue to grow the dynamic array when more space is needed, and implement the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> destructor. Change the original size of your array down to something much smaller (say, four or five elements) and use a mix of the automated test suites and the Interactive PQueue to confirm that your code works as intended. Move on to the next step once all the tests pass.</li>
  <li>Use the Time Tests feature to confirm that the cost of doing n <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code>s followed by n <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code>s is indeed O(n log n). If not, look back over your code and see if you can spot the source of the inefficiency.</li>
  <li>Add in at least one custom test of your own, just to make sure that you’ve covered all the cases you need to cover.</li>
</ol>

<h3 id="problem-notes">Problem Notes</h3>

<p>Some notes on this part of the assignment:</p>
<ul>
  <li><strong><em>If your program mysteriously stops running without warning, it probably crashed.</em></strong> To see where it crashes, run the program in debug mode. You don’t need to set any breakpoints – simply running in debug mode will let the debugger catch where your program crashed. It’ll stop the program at that point as if you’d set a breakpoint there, and you can then walk up and down the call stack, look at local variables, etc. to see what’s going on. Common causes of program crashes this way include the following:
    <ul>
      <li>Writing to an array variable through an uninitialized pointer. If you don’t initialize a pointer, it’s not given a sensible default value. It might be a null pointer, and writing to a null pointer will cause a crash. It might be a pointer to memory you don’t own, which will crash your program. Or it might point to memory you do own, in which case you might see a crash or might not, depending on whether you were (un)lucky.</li>
      <li>Writing to an array variable pointing at deallocated memory. Once you’ve used delete[] to deallocate an array, you should not try reading or writing that memory. (That would be like trying to let yourself into a building you just sold to someone else.)</li>
      <li>Writing past the end of an array. You saw this in the warmup assignment.</li>
      <li>Writing before the start of an array. This can happen if your indices are wrong.</li>
    </ul>
  </li>
  <li><strong><em>The indices in our array-based heap start at one.</em></strong> C++ arrays are zero-indexed. You’ll need to be clever about how you store things. There are many ways to do this – perhaps you will have a dummy element at the start of your array, or perhaps you'll adjust the math to use zero-indexing – but be sure that you keep this in mind when designing your implementation.</li>
  <li>You are, of course, welcome to define private helper functions in <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>. However, please do not change the signatures of any of the functions that we have provided to you.</li>
  <li>If multiple data points are tied for the same weight, you can break those ties however you’d like.</li>
  <li>Read over the comments in <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>, which detail what all of the member functions need to do. They’re there for a reason. 😃</li>
  <li>Our testing harness automatically checks for memory leaks and other types of memory errors. If you allocate memory without later deallocating it, the test driver will tell you how many objects you leaked. You will then need to explore your code to find the source of the memory error.</li>
  <li>The C++ standard libraries contain functions <code class="language-c++ highlighter-rouge"><span class="n">std</span><span class="o">::</span><span class="n">push_heap</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">std</span><span class="o">::</span><span class="n">pop_heap</span></code>. For the purposes of this assignment, please refrain from using those functions.</li>
</ul>

<h2 id="problem-three-streaming-top-k">Problem Three: Streaming Top-k</h2>
<p><strong><em>(This part of the assignment requires you to have <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> working, so we recommend doing it last.)</em></strong></p>

<p>In the previous part of this assignment, you implemented the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type. Your interactions with the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> were focused on getting the thing working, not writing code that takes advantage of what the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> has to offer.</p>

<p>In this last part of the assignment, you’ll switch hats and become a client of your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type. Specifically, you’re going to implement an algorithm that uses the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> as a building block. This will be similar to what you did in Assignment 2, Assignment 3, and Assignment 4 when you interacted with types like <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">Map</span></code> – you used those types to solve problems without thinking too much about how those types were actually implemented.</p>

<p>The problem we’d like you to solve here is called the streaming top-k problem, and it’s defined like this:</p>

<p class="keith-callout">Given a stream of data points, find the k elements in that data stream with the highest weight.</p>

<p>Your task, specifically, is to implement a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector</span><span class="o">&lt;</span><span class="n">DataPoint</span><span class="o">&gt;</span> <span class="n">topK</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a data stream and a number k, then returns the k data points from that stream with the highest weight. If there are fewer than k elements in the data stream, you should return all the elements in that stream. The items should be returned in <em>descending</em> order of weight, so the zeroth element of the returned Vector should be the highest-weight data point, the first should be the data point with the highest weight less than that, etc.</p>

<p>You might have noticed that the input to this function is not provided by a <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">DataPoint</span><span class="o">&gt;</span></code>, but rather by an <code class="language-c++ highlighter-rouge"><span class="n">istream</span></code>, which is usually something you’d hook up to a file or to the console. Why is this?</p>

<p>Imagine you’re working at Google and have a file with how many times each search query was made in a given day. You want to find the 1,000 most popular searches made that day. Google gets billions of search queries in a day, and most computers simply don’t have the RAM to keep all those queries in memory at once. That would mean that you couldn’t create a <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">DataPoint</span><span class="o">&gt;</span></code> to hold all the data points from the file; it would take up more memory than your computer has available!<sup id="footnote1"><a href="#footnotes">1</a></sup></p>

<p>When you read data from a file stream in C++, on the other hand, the full contents of that stream don’t all have to be held in memory at the same time. Instead, whenever you try reading data from the stream, the stream calls out to your computer’s hard drive to get a bit more information.<sup id="footnote2"><a href="#footnotes">2</a></sup> This means that you can process the elements from a data file one at a time without filling up your computer’s memory; the space to hold each element from the file gets recycled each time you pull in a new element.</p>

<p>In the case of this problem, your goal is to implement your function such that you can find the top k elements using only O(k) space; that is, space proportional to the number of elements you’ll need to return. In other words, if you wanted the top 1,000 search queries from Google, it wouldn’t matter that there are billions or tens of billions of search queries per day. You’d only need to use enough space in RAM to hold about a thousand or so of them.</p>

<p>As a reminder, you can read one element at a time from an istream using this general pattern:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">DataPoint</span> <span class="n">pt</span><span class="p">;</span> <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">pt</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>  
    <span class="cm">/* … do something with pt … */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Your solution should not only use little space; it should also run quickly. Specifically, the runtime of your algorithm should be <strong>O(<em>n</em> log <em>k</em>)</strong>, where n is the number of elements in the data stream.</p>

<h3 id="deliverables-2">Deliverables</h3>

<p>Here’s what you need to do for this part of the assignment:</p>

<ol class="keith-deliverables">
  <li>Implement the the <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code> function in <code class="language-c++ highlighter-rouge"><span class="n">TopK</span><span class="p">.</span><span class="n">cpp</span></code>. You will need to use the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type that you built in the previous part of this assignment in the course of doing this. However, you should not modify the files <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code> to solve this problem (unless, of course, you’re fixing bugs in the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type).</li>
  <li>Add at least one custom test case – and, ideally, many more – and test your code thoroughly using the test suite.</li>
  <li>Use the “Time Test” feature to see how fast your code runs, and confirm that the runtimes are consistent with what you’d expect to see in a piece of code whose runtime is O(n log k), where n is the number of elements and k is the input parameter to <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code>.</li>
</ol>

<h3 id="problem-notes-1">Problem Notes</h3>

<p>Here’s some hints to help you get started:</p>
<ul>
  <li>Just to make sure you didn’t miss it, we want you to return the <strong><em>highest-weight</em></strong> elements from the data stream sorted in <strong><em>descending order</em></strong>, which is the reverse of what we’ve asked you to do elsewhere in this assignment.</li>
  <li>Think about how you might solve this problem if you just wanted to find the highest-weight data point in the stream. How would you go about solving that problem using a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>? Now imagine you want to find the top two. How would you do that?</li>
  <li>The runtime bound of O(n log k) might actually give you a hint about how to solve this problem. There are n total elements to process, which means that you can only do O(log k) work per element from the data stream.</li>
  <li>You can assume the data stream only has <code class="language-c++ highlighter-rouge"><span class="n">DataPoints</span></code> in it and don’t need to handle the case where the stream contains malformed data.</li>
  <li>Inserting elements into a Vector using <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">::</span><span class="n">insert</span></code> or removing elements from a Vector using <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">::</span><span class="n">remove</span></code> will take time O(n) if you insert or remove elements from the beginning of the Vector. Be careful when using these functions, since they can degrade performance.</li>
  <li>Be careful – you can only consume the elements of an <code class="language-c++ highlighter-rouge"><span class="n">istream</span></code> once. This means that, for each test you run, you can only call <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code> on a stream once. If you call <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code> a second time on that stream, the stream will appear empty and <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code> will return a different value than the one you got the first time you called <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code>.</li>
</ul>

<p>As with the other parts of this assignment, <strong><em>you must write at least one custom test case</em></strong> for this part of the assignment, and, ideally, should include more than just one. Also, be sure to run the time tests. You should have a sense of the general shapes of the curves you should expect to see, since you already saw some curves from an O(n log k)-time algorithm earlier in this assignment.</p>

<h2 id="optional-problem-four-explore-some-data-sets">(Optional) Problem Four: Explore Some Data Sets!</h2>

<p>The starter files we’ve provided you with in this assignment include four demos that use your code – the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>, and your implementation of <code class="language-c++ highlighter-rouge"><span class="n">topK</span></code> – to explore large data sets. Once you’ve finished the previous parts of this assignment, feel free to play around with these demos to see your code in action!</p>

<ul>
  <li><strong><em>Child Mortality</em></strong>: The United Nations Millennium Development Goals were a set of ambitious targets for improving health and welfare across the globe. Over twenty-five years, the UN kept records of child mortality data worldwide. How did those numbers change since when they started keeping track in 1990 to when the most recent public numbers were released in 2013?</li>
  <li><strong><em>Earthquakes</em></strong>: The US Geological Survey operates a global network of seismometers and publishes lists of earthquakes updated every hour. Where are these earthquakes? How big are they?
A note: for some reason, Qt Creator’s networking system doesn’t work on all computers. You may get error messages here about not being able to connect to the servers. If that happens, don’t worry; it’s not your fault.</li>
  <li><strong><em>Women’s 800m Freestyle</em></strong>: The women’s 800m freestyle swim race was introduced as a competitive event in the 1960s. How have the fastest times in that event improved since then? A certain Stanford-affiliated athlete might make an appearance here.</li>
  <li><strong><em>National Parks</em></strong>: The US National Parks Service runs America’s national parks, national monuments, national recreation areas, national seashores, etc. How many people visit those parks? Which ones are most popular? What trends can you detect by looking at those numbers?</li>
</ul>

<p class="keith-deliverables">There are no deliverables for this part of the assignment. Just sit back, enjoy, and celebrate having gotten everything working!</p>

<h2 id="optional-problem-five-extensions">(Optional) Problem Five: Extensions</h2>

<p>There are many, many ways you could do extensions on this assignment. Here are a few:</p>
<ul>
  <li><strong><em>Priority Queue</em></strong>: There are so many different ways to implement priority queues, of which the binary heap is only one. Other approaches include binomial heaps, pairing heaps, leftist heaps, Fibonacci heaps, hollow heaps, thick heaps, and randomized meldable heaps. These other styles of heaps are designed to efficiently support additional operations on heaps, such as <em>meld</em>, which efficiently merges together two heaps, or <em>decrease-key</em>, which lowers the priority of an existing element in the heap, essentially bumping it up in line. Pick one of these other approaches, research it, and put together your own implementation.</li>
  <li><strong><em>Streaming Top-k</em></strong>: The streaming top-k algorithm is an example of a <em>streaming algorithm</em>, an algorithm that works on a data stream and tries to keep its memory footprint low. Streaming algorithms are an active area of research in algorithms and data structures, and there are some really beautiful ones out there. The <em>count-min sketch</em>, for example, lets you approximate how many times you’ve seen various elements in the data stream without actually storing everything you’ve encountered. Research a streaming algorithm and code up your own implementation.</li>
  <li><strong><em>Data Sagas</em></strong>: This assignment builds up to exploring data sets with these sorts of algorithms to see what you find. So go out there and find a fun data set to explore! Get some data and tell us a good story about it. Which data set did you grab? Where did you find it? What did you find when you looked in that data set?</li>
</ul>

<h2 id="submission-instructions">Submission Instructions</h2>
<p>Once you’ve finished writing up your solution, submit these files:</p>
<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>. (Don’t forget the header file!)</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">TopK</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
</ul>

<p>If you edited any of the other files in the course of adding extensions to the base assignment, please be sure to include them as well.</p>

<p class="text-center"><strong><em>Good luck, and have fun!</em></strong></p>

<hr />

<p class="small"><sup><a href="#footnote1">1</a></sup> Technically, due to the wonder that is virtual memory, you actually could create this Vector. It would just degrade the performance on your machine so much that everything would grind to a seeming halt.</p>

<p class="small"><sup><a href="#footnote2">2</a></sup> Technically, the stream usually uses a technique called buffering where, whenever you ask for data, it reads more data than you need from disk. Reading from disk is much, much slower than reading from memory, and this design helps reduce the amount of time spent asking the hard drive for data.</p>

<p><span id="footnotes"></span></p>
</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials © Stanford University 2020 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2021-Feb-25
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
