<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/class/cs106b/build/_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Recursion!</title>
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
   
    
    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Assignment 3. Recursion!</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<><!-- This boilerplate inserts formatted due date -->

<!--  Boilerplate content for assignment index page -->

<h2 id="due-friday-february-5-at-1130-am-pacific">Due Friday, February 5 at 11:30 am Pacific</h2>

<ul>
  <li>Submissions received by due date receive a small <strong>on-time bonus</strong>.</li>
  <li>All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty.</li>
  <li>The <strong>grace period expires Sun, Feb 7 at 11:30 am Pacific</strong>, after which we cannot accept further late submissions.</li>
  <li>In this course, we express all date/times in <a href="https://www.timeanddate.com/worldclock/@5398563" title="Current time in Pacific">Pacific time GMT -8</a>. Our Paperless submission system also displays/records due dates and submission times in Pacific time.</li>
</ul>

<hr />

<p>This assignment is all about recursive problem-solving. You've practiced writing recursive functions in Assignment 1 and in section, and now it's time to take those skills, combine them with the techniques we've covered over the past couple of lectures, and make some pretty impressive pieces of software.</p>

<p>We've chosen these problems because we think they're a great sampler of the different sorts of fundamental recursive techniques that we've explored. We hope that you find these problems interesting and get a better feel for what recursion can do!</p>

<p><strong><em>Due Friday, February 5th at the start of class.</em></strong></p>

<p><strong><em>You are permitted to work on this assignment in pairs.</em></strong></p>

<p>This assignment has four parts to it, and you have seven days to complete it. We recommend that you start this assignment early and make slow, steady progress throughout the week. Here's a recommended timetable:</p>

<ul>
  <li>Complete the Sierpinski Triangle within a day of this assignment going out.</li>
  <li>Complete Human Pyramids within two days of this assignment going out.</li>
  <li>Complete What Are YOU Doing? within four days of this assignment going out.</li>
  <li>Complete Shift Scheduling within seven days of this assignment going out.</li>
</ul>

<p>Recursive problem-solving can take a bit of time to get used to, and that's perfectly normal. Putting in an hour or two each day working on this assignment will give you plenty of time to adjust and gives you a comfortable buffer in case you get stuck somewhere.</p>

<p>As always, feel free to get in touch with us if you need any assistance.
We're happy to help out!</p>

<p>You are welcome to work in pairs on this assignment. If you do, please note that</p>

<ul>
  <li><strong>it is not a good idea to have one partner do two of the four parts of this assignment and to have the other partner do the other two,</strong> that</li>
  <li><strong>you are responsible for understanding how to solve all of the problems given out here, regardless of how you divvy up the work,</strong> and that</li>
  <li><strong>if you are working in pairs, both partners should be looking at the same screen the whole time the assignment is being worked on.</strong></li>
</ul>

<p>Historically, students that have split the work in half have had substantially below-average learning outcomes in the course, especially when it comes to the exams. On the other hand, students that sit at the same computer and talk through what they're doing with their partner tend to have substantially above-average learning outcomes in the course.</p>

<p>Stated succinctly, <strong><em>pair programming is about working together, not working separately</em></strong>.</p>

<h2 id="problem-one-the-sierpinski-triangle">Problem One: The Sierpinski Triangle</h2>

<p>One of the most famous self-similar fractals is the <strong><em>Sierpinski triangle</em></strong>. As with many self-similar images, it's defined recursively:</p>

<ul>
  <li>An order-0 Sierpinski triangle is a regular, filled triangle.</li>
  <li>An order-n Sierpinski triangle, where <em>n</em> &gt; 0, consists of three
Sierpinski triangles of order <em>n</em> ‚Äì 1, each half as large as the
main triangle, arranged so that they meet corner-to-corner.</li>
</ul>

<p>For example, here are Sierpinski triangles of the first few orders:
<img src="img/0a6983e497b8d576da6570feae4fded5.png" alt="Sierpinski triangles, orders 0 through 4" /></p>

<p>Take a minute to confirm that the order-1 Sierpinski triangle indeed
consists of three smaller copies of the order-0 Sierpinski triangle,
that the order-2 Sierpinski triangle is formed from three smaller copies
of the order-1 Sierpinski triangle, etc.</p>

<p>As a note, although it might look like we're drawing a single black
triangle with a lot of white triangles inside it, that's actually not
the case. Every triangle drawn here is black; the white triangles
represent places where no triangle was drawn.</p>

<p>Your task is to implement a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">drawSierpinskiTriangle</span><span class="p">(</span><span class="n">GWindow</span><span class="o">&amp;</span> <span class="n">window</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y0</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y1</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y2</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
</code></pre></div></div>
<p>that takes as input a window in which to draw the Sierpinski triangle, coordinates of the three points defining the corners of that triangle, and the order of that triangle, then draws the Sierpinski triangle of that order. If the order parameter is less than zero, use the <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> function to report an error.</p>

<p>To draw a triangle, you can use this helpful <code class="language-c++ highlighter-rouge"><span class="n">drawTriangle</span></code> function that we've provided:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">drawTriangle</span><span class="p">(</span><span class="n">GWindow</span><span class="o">&amp;</span> <span class="n">window</span><span class="p">,</span>
                  <span class="kt">double</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y0</span><span class="p">,</span>
                  <span class="kt">double</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y1</span><span class="p">,</span>
                  <span class="kt">double</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y2</span><span class="p">);</span>
</code></pre></div></div>

<p>This function takes in a <code class="language-c++ highlighter-rouge"><span class="n">GWindow</span></code> in which to draw the triangle, along with the coordinates of its three corners, then draws a black triangle with the specified corner coordinates.</p>

<p>To summarize, here's what you need to do:</p>

<div style="border: 3px solid black; background-color:#ffffc0">
  <h4 id="problem-1-requirements">Problem 1 Requirements</h4>
  <ol>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">drawSierpinskiTriangle</span></code> function in <code class="language-c++ highlighter-rouge"><span class="n">Sierpinski</span><span class="p">.</span><span class="n">cpp</span></code>. Don‚Äôt forget to handle the case where the order is negative.</li>
    <li>Use the ‚ÄúInteractive Sierpinski‚Äù option to check your work. In particular, make sure your triangle looks correct after dragging the corner points around and changing the order of the triangle via the slider in the bottom of the window.</li>
  </ol>
</div>

<p>Once you've gotten that working, click "Sierpinski Bungee Jump" to see just how deep the recursion rabbit hole goes. And yes, that's your code powering the bungee jump. We're just specifying coordinates. üòÉ</p>

<p>Some notes on this problem:</p>

<ul>
  <li>
    <p><strong>Draw pictures!</strong> The meat of this part of the assignment is figuring out where each triangle's corners are, and that's much easier to do with a schematic in front of you.</p>
  </li>
  <li>
    <p>Some helpful math: the midpoint of a line segment whose endpoints are (x‚ÇÅ, y‚ÇÅ) and (x‚ÇÇ, y‚ÇÇ) is located at position ((<em>x</em>‚ÇÅ + <em>x</em>‚ÇÇ)/2, (<em>y</em>‚ÇÅ + <em>y</em>‚ÇÇ)/2). You may find this useful when determining where the corners of the smaller triangles are.</p>
  </li>
  <li>
    <p>The three corner points of the triangle don't necessarily have to form an equilateral triangle or be parallel to the base or side of the window. There isn't any particular ordering to which corner is given by (<em>x</em>‚ÇÄ, <em>y</em>‚ÇÄ), which is given by (<em>x</em>‚ÇÅ, <em>y</em>‚ÇÅ), and which is given by (<em>x</em>‚ÇÇ, <em>y</em>‚ÇÇ).</p>
  </li>
  <li>
    <p>Repeating a point from earlier ‚Äì you should only draw the black triangles that make up the Sierpinski triangle. The white parts of the triangle are, in a sense, "negative space;" they're the regions where nothing is drawn.</p>
  </li>
  <li>
    <p>The only function you should call to draw things in the window is <code class="language-c++ highlighter-rouge"><span class="n">drawTriangle</span></code>, which we mentioned earlier in this handout. You don't need to, say, call the <code class="language-c++ highlighter-rouge"><span class="n">drawPolarLine</span></code> function from lecture or anything like that.</p>
  </li>
  <li>
    <p>Don't forget to call <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> in the case where the order is less than zero.</p>
  </li>
  <li>
    <p>Our coordinate system uses real numbers. Remember that C++ has separate types for integers and real numbers and be careful not to mix the two up.</p>
  </li>
</ul>

<h2 id="problem-two-human-pyramids">Problem Two: Human Pyramids</h2>
<p>A human pyramid is a way of stacking people vertically. With the exception of the people in the bottom row, each person splits their weight evenly on the two people below them in the pyramid.</p>

<p>For example, imagine a pyramid where person A is at the very top, the tip of the triangle, sitting on top of people B and C in the row directly below. In the row directly below B and C are people D, E, and F (this is the third row from the top). In the row below that (the fourth row from the top) are people G, H, I, and J, and in the bottommost row (the fifth row from the top) are people K, L, M, N, and O.</p>

<p><img src="img/humanpyramid.png" alt="A human pyramid. The person on top is labeled A. Beneath person A are people B and C. Beneath B and C are people D, E, and F. Beneath D, E, and F are G, H, I, and J. Beneath G, H, I, and J are K, L, M, N, and O. Person A, B, and C are smiling. The people toward the bottom of the pyramid appear to be in pretty signficant pain due to all the weight they're carrying." /></p>

<p>In the pyramid described above, person <em>A</em> splits her weight across people <em>B</em> and <em>C</em>, and person <em>H</em> splits his weight ‚Äì plus the accumulated weight of the people he's supporting ‚Äì onto people <em>L</em> and <em>M</em>. It can be mighty uncomfortable to be in the bottom row, since you'll have a lot of weight on your back! In this question, you'll explore just how much weight that is. Just so we have nice round numbers here, let's assume that everyone in the pyramid weighs exactly 160 pounds.</p>

<p>Person <em>A</em> at the top of the pyramid has no weight on her back. People <em>B</em> and <em>C</em> each carry half of person <em>A</em>'s weight, so each shoulders 80 pounds. Uncomfortable, but not too bad.</p>

<p>Now, let's consider the people in the third row. Focus on person <em>E</em>. How muchweight is she supporting? Well, she's directly supporting half the weight of person <em>B</em> (80 pounds) who is immediately above and to the left of her, and half the weight of person <em>C</em> (80 pounds) who is immediately above and to the right of her. On top of this, she's feeling some of the weight people <em>B</em> and <em>C</em> are carrying. Half of the weight that person <em>B</em> shoulders (40 pounds) gets transmitted to person <em>E</em> and half the weight person <em>C</em> shoulders (40 pounds) similarly gets sent down to person <em>E</em>, so person <em>E</em> ends up feeling an extra 80 pounds. That means she's supporting a net total of 240 pounds. That's going to be noticeable!</p>

<p>Not everyone in that third row is feeling the same amount, though; let's take person <em>D</em> for example. The only weight on person <em>D</em> comes from person <em>B</em> in the row above them to their right, because no one is sitting above their left shoulder. Person <em>D</em> therefore ends up supporting</p>

<ul>
  <li>half of person <em>B</em>'s body weight (80 pounds), plus</li>
  <li>half of the weight person <em>B</em> is holding up (40 pounds),</li>
</ul>

<p>so person <em>D</em> ends up supporting 120 pounds, only half of what <em>E</em> is feeling! Going deeper in the pyramid, how much weight is person <em>H</em> feeling? Well, person <em>H</em> is supporting</p>

<ul>
  <li>half of person <em>D</em>'s body weight (80 pounds),</li>
  <li>half of person <em>E</em>'s body weight (80 pounds), plus</li>
  <li>half of the weight person <em>D</em> is holding up (60 pounds), plus</li>
  <li>half of the weight person <em>E</em> is holding up (120) pounds.</li>
</ul>

<p>The net effect is that person <em>H</em> is carrying 340 pounds ‚Äì ouch! A similar calculation shows that person <em>I</em> is also carrying 340 pounds ‚Äì can you see why? Compare this to person <em>G</em>. Person <em>G</em> is supporting</p>

<ul>
  <li>half of person <em>D</em>'s body weight (80 pounds), plus</li>
  <li>half of the weight person <em>D</em> is holding up (60 pounds),</li>
</ul>

<p>for a net total of 140 pounds. That's a lot, but it's not nearly as bad as what person <em>H</em> is feeling! Finally, let's look at poor person <em>M</em> in the middle of the bottom row. How is he doing? Well, he's supporting</p>

<ul>
  <li>half of person <em>H</em>'s body weight (80 pounds),</li>
  <li>half of person <em>I</em>'s body weight (80 pounds),</li>
  <li>half of the weight person <em>H</em> is holding up (170 pounds), and</li>
  <li>half of the weight person <em>I</em> is holding up (170 pounds),</li>
</ul>

<p>for a net total of 500 pounds. Yikes! No wonder he looks so unhappy.</p>

<p>There's a nice, general pattern here that lets us compute how much weight is on each person's back:</p>

<ul>
  <li>Each person weighs exactly 160 pounds.</li>
  <li>Each person supports half the body weight of each of the people
immediately above them, plus half of the weight that each of those
people are supporting.</li>
</ul>

<p>The question then becomes ‚Äì given some person in the pyramid, how much weight are they supporting?</p>

<h3 id="milestone-1-the-initial-implementation">Milestone 1: The Initial Implementation</h3>

<p>Using the pattern mentioned above, as your first milestone for this problem, write a recursive function</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">weightOnBackOf</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pyramidHeight</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input the row and column number of a person in a human pyramid, along with the number of rows in the pyramid (its height), then returns the total weight on that person's back.</p>

<p>The coordinate system we're using for these pyramids works as follows. Rows increase from top to bottom. The topmost row is row 0, the row below that is row 1, then row 2, etc. Columns increase from left to right, with the leftmost person in each row being in column 0, the person to their right being in column 1, etc.</p>

<p><img src="img/humanpyramid_milestone1.png" alt="A human pyramid annotated with coordinates. The topmost person is at postiion (0, 0). Below her are people at positions (1, 0) and (1, 1). Below them are people at positions (2, 0), (2, 1), and (2, 2). And below that are people at positions (3, 0), (3, 1), (3, 2), and (3, 3)." /></p>

<p>In our previous example, person A would be at position (0,0) since she's at the top of the pyramid. Person B would be at position (1,0) since she's the leftmost person in the next row down, and so on and so forth, until Person O, who is at position (4,4). Recall that in our previous pyramid there were 5 rows and the bottommost row has 5 people in it, people K through O.</p>

<p>If the provided (row, col) position passed into <em>weightOnBackOf</em> is out of bounds you should use the <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> function to report an error. For example, if you're asked to look up position (-1, 0), or position (2, 3), you'd always report an error. Position (3, 1) is in-bounds provided that the pyramid height is at least four, but would be out of bounds if the pyramid height was one, two, or three.</p>

<p>Your implementation of <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span></code> must be implemented recursively. <strong>Test your solution thoroughly!</strong> You should write at least one test before moving on.</p>

<p>To summarize, here's what you need to do:</p>

<div style="border: 3px solid black; background-color:#ffffc0">
  <h4 id="milestone-1-requirements">Milestone 1 Requirements</h4>
  <ol>
    <li>Add at least one test to <code class="language-c++ highlighter-rouge"><span class="n">HumanPyramids</span><span class="p">.</span><span class="n">cpp</span></code> to cover a case not tested by the other test cases. This is a great opportunity to check that you understand the problem setup.</li>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span></code> function from HumanPyramids.cpp to report the weight on the back of the indicated person in a human pyramid. Test your solution thoroughly before proceeding, noting that your implementation will be slow if you look deep in the pyramid. Don‚Äôt forget to call <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> if the input coordinates are out of bounds!</li>
  </ol>
</div>

<p>Some notes on this first milestone:</p>

<ul>
  <li>Remember that the <code class="language-c++ highlighter-rouge"><span class="kt">int</span></code> and <code class="language-c++ highlighter-rouge"><span class="kt">double</span></code> types are distinct in C++, and be careful not to mix them up. Your weight calculations should be done with <code class="language-c++ highlighter-rouge"><span class="kt">double</span></code>s.</li>
  <li>Due to the way that the <code class="language-c++ highlighter-rouge"><span class="kt">double</span></code> type works in C++, the values that you get back from your program in large pyramids might contain small rounding errors that make the value close to, but not exactly equal to, the true value (we're talking about very small errors ‚Äì less than a part in a thousand). Don't worry if this happens.</li>
</ul>

<h3 id="milestone-2-speeding-things-up">Milestone 2: Speeding Things Up</h3>

<p>When you first code up this function, you'll find that it's pretty quick to tell you how much weight is on the back of the person in row 5, column 3, but that it takes a long time to say how much weight is on the back of the person in row 30, column 15. Why is this?</p>

<p>Think about what happens if we call <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span></code>. (For simplicity of exposition in this section, we're going to leave off the height parameter.) This makes two new recursive calls: one to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></code>, and one to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span></code>. This first recursive call in turn fires off two more: one to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span></code> and another to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></code>. The second recursive call then calls <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span></code>.</p>

<p>Notice that there are two calls to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></code> here. This means that there's a redundant call being made to <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></code>, so all the work done to compute that intermediate answer is done twice. That call will in turn fire off its own redundant recursive calls, which in turn fire off their own redundant calls, etc. This might not seem like much, but the number of recursive calls can be huge. For example, calling <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span></code> makes over 600,000,000 recursive calls!</p>

<p>There are many techniques for eliminating redundant calls. One common approach is <strong><em>memoization</em></strong> (no, that's not a typo). Intuitively, memoization works by making an auxiliary table keeping track of all the recursive calls that have been made before and what value was returned for each of them. Then, whenever a recursive call is made, the function first checks the table before doing any work. If the the recursive call has already been made in the past, the function just returns that stored value. This prevents values from being computed multiple times, which can dramatically speed things up!</p>

<p>In pseudocode, memoization looks something like this:
<strong>Before:</strong></p>
<div class="language-c++ nosyntaxerror highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ret</span> <span class="nf">function</span><span class="p">(</span><span class="n">Arg</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-</span><span class="k">case</span><span class="o">-</span><span class="n">holds</span><span class="p">)</span> <span class="err">{</span>
      <span class="k">return</span> <span class="n">base</span><span class="o">-</span><span class="k">case</span><span class="o">-</span><span class="n">value</span><span class="p">;</span>
   <span class="err">}</span> <span class="k">else</span> <span class="err">{</span>
      <span class="k">do</span><span class="o">-</span><span class="n">some</span><span class="o">-</span><span class="n">work</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">recursive</span><span class="o">-</span><span class="n">step</span><span class="o">-</span><span class="n">value</span><span class="p">;</span>
   <span class="err">}</span>
<span class="err">}</span>
</code></pre></div></div>
<p><strong>After:</strong></p>
<div class="language-c++ nosyntaxerror highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ret</span> <span class="nf">functionRec</span><span class="p">(</span><span class="n">Arg</span> <span class="n">a</span><span class="p">,</span> <span class="n">Table</span><span class="o">&amp;</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-</span><span class="k">case</span><span class="o">-</span><span class="n">holds</span><span class="p">)</span> <span class="err">{</span>
      <span class="k">return</span> <span class="n">base</span><span class="o">-</span><span class="k">case</span><span class="o">-</span><span class="n">value</span><span class="p">;</span>
   <span class="err">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="n">contains</span> <span class="n">a</span><span class="p">)</span> <span class="err">{</span>
      <span class="k">return</span> <span class="n">table</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
   <span class="err">}</span> <span class="k">else</span> <span class="err">{</span>
      <span class="k">do</span><span class="o">-</span><span class="n">some</span><span class="o">-</span><span class="n">work</span><span class="p">;</span>
      <span class="n">table</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">recursive</span><span class="o">-</span><span class="n">step</span><span class="o">-</span><span class="n">value</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">recursive</span><span class="o">-</span><span class="n">step</span><span class="o">-</span><span class="n">value</span><span class="p">;</span>
   <span class="err">}</span>
<span class="err">}</span>

<span class="n">Ret</span> <span class="n">function</span><span class="p">(</span><span class="n">Arg</span> <span class="n">a</span><span class="p">)</span> <span class="err">{</span>
    <span class="n">Table</span> <span class="n">table</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">functionRec</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<p>In the above pseudocode, we're making reference to a type called <strong><em>Table</em></strong>. There isn't actually a type <strong><em>Table</em></strong>; rather, it's a placeholder for "some type that you can use to look up a value associated with the arguments to the function." We'll leave it up to you to decide what type is best for this.</p>

<p>Notice that this transformation makes what was the original function a wrapper function. That's necessary both because we need to create the table somewhere and because we don't want folks using the function to see that the extra parameters have been added in.</p>

<p>As a final step, modify <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span></code> so that it uses memoization to avoid recomputing values unnecessarily. The <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span></code> function must still take the same arguments as before, since our starter code expects to be able to call it with just three arguments (row, column, and height), so you'll need to make it a wrapper function. Once you've done that, try comparing how long it takes to evaluate <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span></code> both with and without memoization. Notice a difference? For fun, try computing <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span></code>. This will take a staggeringly long time to complete without memoization ‚Äì the sun will probably burn out before you get an answer ‚Äì but with memoization you should get back an answer instantly!</p>

<p>To summarize what you need to do:</p>

<div style="border: 3px solid black; background-color:#ffffc0">
  <h4 id="milestone-2-requirements">Milestone 2 Requirements</h4>
  <p>Speed up your implementation by modifying it to use memoization. Test your solution thoroughly using our provided tests, plus any others you add.</p>
</div>

<p>Some notes on this milestone:</p>
<ul>
  <li>We‚Äôve included a stress test to make sure that memoization is working correctly. Because it can take a lot of CPU time if memoization isn‚Äôt implemented correctly, we‚Äôve pro-grammed the test to always fail until you explicitly turn the test on. Follow the instruc-tions given in the test failure to enable the test.</li>
  <li>One of the bigger questions you‚Äôll need to think through is what type to use to represent the memoization table. There are lots of different options here. Fundamentally, you need something where you can input a (row, col) pair and get back a value. There are lots of containers you can use for this, and lots of ways to represent (row, col) pairs. Some are easier to work with than others. Try things out and see what you find!</li>
  <li>Do not add or remove parameters from the <code class="language-c++ highlighter-rouge"><span class="n">weightOnBackOf</span></code> function. Instead, make it a wrapper around a new function that actually does all the recursive magic.</li>
</ul>

<p>Once you‚Äôve finished this milestone, choose the ‚ÄúHuman Pyramids‚Äù option from the menu bar at the top of the program and drag the slider around to change the height of the pyramid. What numbers do you get back? Does that surprise you?</p>

<h2 id="problem-three-what-are-you-doing">Problem Three: What Are YOU Doing?</h2>

<p>In conversational English, emphasizing different words in a sentence can change its meaning. For example, the statement</p>

<blockquote>
  <p>"what are YOU doing?"</p>
</blockquote>

<p>places the emphasis on the person being spoken to, with the connotation being "what are you, as opposed to the other people here, doing?" On the other hand, the statement</p>

<blockquote>
  <p>"what are you DOING?"</p>
</blockquote>

<p>puts the emphasis on "doing," with the connotation that the speaker is exasperated or surprised by the listener's behavior. Contrast that with</p>

<blockquote>
  <p>"WHAT ARE YOU DOING?,"</p>
</blockquote>

<p>which sounds like someone is shouting, or</p>

<blockquote>
  <p>"what ARE you doing?,"</p>
</blockquote>

<p>which reads as a request for clarification about what the listener happens to be doing at the moment.</p>

<p>All in all, there are sixteen different ways we could emphasize the words in this sentence:</p>
<ul>
  <li>what are you doing?</li>
  <li>what are you DOING?</li>
  <li>what are YOU doing?</li>
  <li>what are YOU DOING?</li>
  <li>what ARE you doing?</li>
  <li>what ARE you DOING?</li>
  <li>what ARE YOU doing?</li>
  <li>what ARE YOU DOING?</li>
  <li>WHAT are you doing?</li>
  <li>WHAT are you DOING?</li>
  <li>WHAT are YOU doing?</li>
  <li>WHAT are YOU DOING?</li>
  <li>WHAT ARE you doing?</li>
  <li>WHAT ARE you DOING?</li>
  <li>WHAT ARE YOU doing?</li>
  <li>WHAT ARE YOU DOING?</li>
</ul>

<p>Your task is to write a function</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">allEmphasesOf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">sentence</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a <code class="language-c++ highlighter-rouge"><span class="n">string</span></code> containing a sentence, then returns a <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code> containing all the ways of capitalizing the words in that sentence.</p>

<p>The input to this function is a string representing a sentence. It's probably a lot easier to work not with a single string representing a whole sentence, but with a <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span></code> representing all the pieces of that sentence. For this purpose, we've provided you with</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tokenize</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">sentence</span><span class="p">);</span>
</code></pre></div></div>

<p>which takes as input a sentence, then returns a <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span></code> representing the individual units that make up that sentence. For example, given the input</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quoth</span> <span class="n">the</span> <span class="n">raven</span><span class="p">,</span> <span class="s">"Nevermore."</span>
</code></pre></div></div>

<p>the <code class="language-c++ highlighter-rouge"><span class="n">tokenize</span></code> function would return the <code class="language-c++ highlighter-rouge"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span></code> shown here:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Quoth</span><span class="p">]</span> <span class="p">[</span> <span class="p">]</span> <span class="p">[</span><span class="n">the</span><span class="p">]</span> <span class="p">[</span> <span class="p">]</span> <span class="p">[</span><span class="n">raven</span><span class="p">]</span> <span class="p">[,]</span> <span class="p">[</span> <span class="p">]</span> <span class="p">[</span><span class="s">"] [Nevermore] [.] ["</span><span class="p">]</span>
</code></pre></div></div>

<p>Calling <code class="language-c++ highlighter-rouge"><span class="n">allEmphasesOf</span><span class="p">(</span><span class="s">"Quoth the raven, </span><span class="se">\"</span><span class="s">Nevermore.</span><span class="se">\"</span><span class="s">"</span><span class="p">)</span></code> should return these strings:</p>
<ul>
  <li>quoth the raven, "nevermore."</li>
  <li>quoth the raven, "NEVERMORE."</li>
  <li>quoth the RAVEN, "nevermore."</li>
  <li>quoth the RAVEN, "NEVERMORE."</li>
  <li>quoth THE raven, "nevermore."</li>
  <li>quoth THE raven, "NEVERMORE."</li>
  <li>quoth THE RAVEN, "nevermore."</li>
  <li>quoth THE RAVEN, "NEVERMORE."</li>
  <li>QUOTH the raven, "nevermore."</li>
  <li>QUOTH the raven, "NEVERMORE."</li>
  <li>QUOTH the RAVEN, "nevermore."</li>
  <li>QUOTH the RAVEN, "NEVERMORE."</li>
  <li>QUOTH THE raven, "nevermore."</li>
  <li>QUOTH THE raven, "NEVERMORE."</li>
  <li>QUOTH THE RAVEN, "nevermore."</li>
  <li>QUOTH THE RAVEN, "NEVERMORE."</li>
</ul>

<p>These strings are formed by considering all possible ways of rendering each word in both upper-case and lower-case, keeping the rest of the input string (spaces, commas, periods, etc.) unchanged. You should consider a word to be any string that starts with a letter.</p>

<p>Test your code thoroughly! Our provided starter code has some sample tests included, but they aren't exhaustive and you'll need to expand them. You will need to write at least one custom test case, and we recommend adding even more.</p>

<p>To summarize, here's what you need to do:</p>

<div style="border: 3px solid black; background-color:#ffffc0">
  <h4 id="problem-three-requirements">Problem Three Requirements</h4>
  <ol>
    <li>Implement the function <code class="language-c++ highlighter-rouge"><span class="n">allEmphasesOf</span></code> in <code class="language-c++ highlighter-rouge"><span class="n">WhatAreYouDoing</span><span class="p">.</span><span class="n">cpp</span></code> so that it returns a set of all the different ways the words in the input sentence can be capitalized. The non-word strings in the sentence should be included in the output unchanged from the original.</li>
    <li>Add at least one test case in to the list of test cases, then test thoroughly.</li>
    <li>After your code passes all the tests, play around with the demo app to have some fun with your program.</li>
  </ol>
</div>

<p>Some notes on this problem:</p>

<ul>
  <li>We recommend that your implementation call <code class="language-c++ highlighter-rouge"><span class="n">tokenize</span></code> exactly once to convert the input string into a sequence of tokens; there's no need to call <code class="language-c++ highlighter-rouge"><span class="n">tokenize</span></code> repeatedly.</li>
  <li>You should completely ignore the initial capitalization of the words in the input sentence. For example, the result of calling <code class="language-c++ highlighter-rouge"><span class="n">allEmphasesOf</span></code> on the strings "Happy birthday!,"* <em>"HAPPY BIRTHDAY!,"</em> and <em>"hApPy BiRtHdAy!"</em> should all be the same.</li>
  <li>To check if a string represents a word, check if its first character is a letter. Use the <code class="language-c++ highlighter-rouge"><span class="n">isalpha</span></code> function from the header file <code class="language-c++ highlighter-rouge"><span class="o">&lt;</span><span class="n">cctype</span><span class="o">&gt;</span></code> to do this. You don't need to handle the case where a string has letters in it but not in the first position.</li>
  <li>Use the <code class="language-c++ highlighter-rouge"><span class="n">toUpperCase</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">toLowerCase</span></code> functions from <code class="language-c++ highlighter-rouge"><span class="s">"strlib.h"</span></code> to convert a string to upper-case or lower-case. Be careful ‚Äì these functions don't modify their arguments, and instead return new strings with the case of the letters changed.</li>
  <li>There may not be any words in the input sentence. For example, the input sentence might just be a smiley face emoticon (<em>":-)"</em>) or a series of numbers (<em>"867-5309"</em>).</li>
  <li>You don't need to ‚Äì and in fact, shouldn't ‚Äì use the <code class="language-c++ highlighter-rouge"><span class="n">stringSplit</span></code> function or <code class="language-c++ highlighter-rouge"><span class="n">TokenScanner</span></code> type to break the original string apart into words. Instead, rely on our handy <code class="language-c++ highlighter-rouge"><span class="n">tokenize</span></code> function, which we've written for you specifically for this assignment.</li>
  <li>Make sure that your solution doesn‚Äôt generate the same string more than once. In particular, make sure that your solution doesn‚Äôt call <code class="language-c++ highlighter-rouge"><span class="n">toUpperCase</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">toLowerCase</span></code> on non-word tokens. If your recursion branches, making one call where the punctuation symbol is converted to upper case and another call where the punctuation symbol is converted to lower case, then it will do a lot of unnecessary work regenerating the same strings twice. (Do you see why?)</li>
  <li>C++, unfortunately, is pretty bad when it comes to handling non-English characters. As a result, if you feed perfectly reasonable statements like "‡§®‡§Æ‡§∏‡•ç‡§§‡•á" or "Ÿ±ŸÑÿ≥ŸéŸëŸÑŸéÿßŸÖŸè ÿπŸéŸÑŸéŸäŸíŸÉŸèŸÖŸí" or "‰Ω†Â•Ω" into the <code class="language-c++ highlighter-rouge"><span class="n">tokenize</span></code> function, the results may be completely wrong.</li>
</ul>

<h2 id="problem-four-shift-scheduling">Problem Four: Shift Scheduling</h2>
<p><strong><em>(We recommend completing Problem Three before starting on this part of the assignment.)</em></strong></p>

<p>You're in charge of a small business and have just hired a new part-time employee with flexible hours to help out. You'd like to schedule her hours in a way that gets her to produce the most value.</p>

<p>For each shift, you have an estimate of how much money the employee would produce if she worked that shift. Ideally, you'd have her work <em>every</em> shift, but alas, that isn't possible. There are two restrictions. First, the employee has a limited number of hours she's allowed to work each week. Second, you can't assign the employee to work concurrent shifts. (As great a hire as she was, she can only be in one place at one time). Given these restrictions, what shifts should you assign to your new hire?</p>

<p>For example, imagine that your new employee is available for twenty hours each week. There's a variety of tasks she could do, each of which has different shifts. Here's the different shifts she could take, as well as how much value (measured in dollars) she'll produce in each:</p>

<ul>
  <li>Mon  8AM - 12PM: $27</li>
  <li>Mon 12PM -  4PM: $28</li>
  <li>Mon  4PM -  8PM: $25</li>
  <li>Mon  8AM -  2PM: $39</li>
  <li>Mon  2PM -  8PM: $31</li>
  <li>Tue  8AM - 12PM: $7</li>
  <li>Tue 12PM -  4PM: $7</li>
  <li>Tue  4PM -  8PM: $11</li>
  <li>Tue  8AM -  2PM: $10</li>
  <li>Tue  2PM -  8PM: $8</li>
  <li>Wed  8AM - 12PM: $10</li>
  <li>Wed 12PM -  4PM: $11</li>
  <li>Wed  4PM -  8PM: $13</li>
  <li>Wed  8AM -  2PM: $19</li>
  <li>Wed  2PM -  8PM: $25</li>
</ul>

<p>So, when should she come in to work? You might be eyeing the high-value Monday 8:00AM ‚Äì 2:00PM and 2:00PM ‚Äì 8:00PM time slots. That would bring in a full $70, using up twelve of her permitted twenty hours. You might then have her spend her remaining eight hours Wednesday afternoon in the 12:00PM ‚Äì 4:00PM and 4:00PM ‚Äì 8:00PM shifts, netting you another $24 for a total take-home of $94.</p>

<p>With a little creativity, though, you might note that you actually would make more if instead of having her work eight hours on Wednesday in two four-hour time slots, you instead had her work six hours from 2:00PM ‚Äì 8:00PM and bring in $25 of value, simultaneously upping your total take-home to $95 and giving her two free hours.</p>

<p>Even this isn't optimal ‚Äì as enticing as those $39 and $31 time slots on Monday are, it's actually better to have your employee work the three four-hour shifts on Monday, bringing in $27, $28, and $25, respectively, for a total of $80 on Monday. Overall, if you pick the three four-hour shifts on Monday and the closing six-hour shift on Wednesday, your new hire is bringing in $105 and clocking in only eighteen hours, below the twenty-hour limit.</p>

<p>Your task is to write a function</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="n">Shift</span><span class="o">&gt;</span> <span class="n">highestValueScheduleFor</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Shift</span><span class="o">&gt;&amp;</span> <span class="n">shifts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxHours</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code> of all the possible shifts, along with the maximum number of hours the employee is allowed to work for, then returns which shifts the employee should take in order to generate the maximum amount of value. Here, <code class="language-c++ highlighter-rouge"><span class="n">Shift</span></code> is a <code class="language-c++ highlighter-rouge"><span class="k">struct</span></code> containing information about when the shift is (what day of the week it is, when it starts, and when it ends). It's defined in the header file <code class="language-c++ highlighter-rouge"><span class="n">Shift</span><span class="p">.</span><span class="n">h</span></code>. Chances are that you won't need to read any of the fields of this <code class="language-c++ highlighter-rouge"><span class="k">struct</span></code>, and that instead you'll want to use these functions from <code class="language-c++ highlighter-rouge"><span class="n">Shift</span><span class="p">.</span><span class="n">h</span></code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lengthOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Shift</span><span class="o">&amp;</span> <span class="n">shift</span><span class="p">);</span>    <span class="c1">// Returns the length of a shift.     </span>
<span class="kt">int</span> <span class="nf">valueOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Shift</span><span class="o">&amp;</span> <span class="n">shift</span><span class="p">);</span>     <span class="c1">// Returns the value of this shift.   </span>
<span class="kt">bool</span> <span class="nf">overlapsWith</span><span class="p">(</span><span class="k">const</span> <span class="n">Shift</span><span class="o">&amp;</span> <span class="n">one</span><span class="p">,</span>  <span class="c1">// Returns whether two shifts overlap.</span>
                  <span class="k">const</span> <span class="n">Shift</span><span class="o">&amp;</span> <span class="n">two</span><span class="p">);</span> 
</code></pre></div></div>

<p>Now, let's talk strategy. We recommend approaching this problem in the following way. Select, however you'd like, some shift out of <code class="language-c++ highlighter-rouge"><span class="n">shifts</span></code>. If the employee can't take this shift, either because it overlaps with a shift she's already been assigned or because it would exceed her total hour limit, then the only option is to not give the employee that shift. Otherwise, there are two options: you could either give the employee the shift, or not give the employee the shift. One of these two options will be better than the other, or they'll be tied for how much value is produced. You won't know which one is better until you try them out, so (recursively) explore both options and report whichever one leads to more value.</p>

<p>As you're working on this one, make sure to test thoroughly! If you have forty or so shifts to pick from, it'll be extremely difficult to determine whether your code produces the best option simply by eyeballing the answer. Instead, craft smaller examples (say, with between zero and five shifts) and see how your code does. Think of all the tricksy cases that might arise ‚Äì long shifts that aren't worth much, short shifts worth a lot, overlapping shifts that are equally good, etc. ‚Äì and make sure your code handles those cases well. We've included some tests for you to use when you're getting started, and there's at least one case we know of that we didn't test for. As usual, you'll need to add at least one custom test case of your own.</p>

<p>With that said, here's what you need to do:</p>

<div style="border: 3px solid black; background-color:#ffffc0">
  <h4 id="problem-four-requirements">Problem Four Requirements</h4>
  <ol>
    <li>Implement <code class="language-c++ highlighter-rouge"><span class="n">highestValueScheduleFor</span></code> using the strategy we outlined above. Select some shift and think about what happens if you assign the employee that shift (if that‚Äôs even an option) and what happens if you don‚Äôt assign the employee that shift. Take whichever option leads to a better result, and report the set of shifts you‚Äôd pick if you chose that route. Use the <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> function to report an error if <code class="language-c++ highlighter-rouge"><span class="n">numHours</span> <span class="o">&lt;</span> <span class="mi">0</span></code>.</li>
    <li>Add at least one test using <code class="language-c++ highlighter-rouge"><span class="n">STUDENT_TEST</span></code>. Ideally, test something not already covered.</li>
  </ol>
</div>

<p>Some notes on this problem:</p>
<ul>
  <li>You may find it easiest to work on this in stages. First, solve this problem ignoring the restriction that you can‚Äôt pick two overlapping shifts. Then, once you have that version working, edit your solution to enforce that you can‚Äôt pick overlapping shifts.</li>
  <li>If multiple schedules are tied for producing the most value, you‚Äôre free to choose any of them.</li>
  <li>While you are allowed to look directly at the fields of the <code class="language-c++ highlighter-rouge"><span class="n">Shift</span></code> struct, we don‚Äôt recommend this. Use the helper functions mentioned on the previous page instead.</li>
  <li>The best schedule might not use up all of the employee's available hours.</li>
  <li>The values assigned to shifts can be arbitrary. It might be the case that a shift from 2PM to 4PM produces ten units of value while another from 10AM to 6PM the same day produces four.</li>
  <li>
    <p>It‚Äôs fine if the worker has zero available hours ‚Äì that just means that she‚Äôs really busy that week ‚Äì but if <code class="language-c++ highlighter-rouge"><span class="n">maxHours</span></code> is negative you should call <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> to report an error.</p>
  </li>
  <li>There are two general strategies you can use to explore sets of shifts. One option is to generate all possible combinations of shifts, checking only at the end to see whether the shifts overlap with one another or exceed the hourly limits. You should avoid this option ‚Äì the number of choices of shifts is so huge that this will not finish running in any rea-sonable timeframe. The other is to only build up collections of shifts that, at the time they‚Äôre built, are known not to exceed the time limit or to contain overlapping shifts. You should favor this approach, since it significantly reduces the number of shift sets to check.</li>
</ul>

<p>Once you've finished writing your solution, try running our demo program, which will let you generate random weights on some standard shift sets and see what schedules end up getting chosen.</p>

<p>Here's something to think about. Some companies assign different shifts to workers each week, and they do so by running code that's pretty similar to the code you wrote here, feeding in weekly forecasts. As you can see from the demo program, this can easily lead to schedules that vary wildly from week to week. If the person you're hiring needs to arrange for child care each week, this rapid swing in shift selection can be extremely stressful. In fact, this has been so rough on workers that <a href="https://www.nytimes.com/interactive/2014/08/13/us/starbucks-workers-scheduling-hours.html">it made national news</a>.</p>

<p>So take a look at the code that you wrote. We assume that nothing in your code says something like this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">isSingleMother</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">chooseShiftsArbitrarilyAndCapriciously</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">chooseStableShifts</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Instead, what's happening here is that your code is designed to purely optimize a single quantity ‚Äì the amount of revenue generated by the employee ‚Äì and doesn't take anything else into account. Your code isn't malicious; it just oblivious to the surrounding context.</p>

<p>The lesson here is to <em>be careful about what you optimize</em>. Computers can help you find strategies that maximize lots of different quantities. Make sure you pick a quantity that takes in the perspectives of all the stakeholders in a situation. Get it right and you end up with schedules where workers are happy and companies make money. Get it wrong and you significantly impair quality of life.</p>

<h2 id="optional-problem-five-extensions">(Optional) Problem Five: Extensions!</h2>
<p>Want more to explore? Here are a few suggestions to help you get started. As always, if you‚Äôre planning on doing extensions, please submit two versions of your assignment ‚Äì one with exten-sions and one without ‚Äì so that grading goes more smoothly.</p>

<ul>
  <li><strong><em>Sierpinski Triangle:</em></strong> The Sierpinski triangle is only one of many self-similar images; con-sider coding up another! We‚Äôd love to see what you create. Alternatively, although this assignment is all about recursion, if you're up for a challenge, try replacing the recursive version of your code with an iterative function that draws an order-n Sierpinski triangle. Which one did you find easier to write?</li>
  <li><strong><em>Human Pyramids:</em></strong> There's another way to avoid making multiple recursive calls called dynamic programming that's equivalent to memoization, but uses iteration rather that re-cursion. Look up dynamic programming and try coding this function up both ways. Which one do you find easier? Another question to consider: We assumed everyone in the pyramid weighed exactly 160 pounds. What if that‚Äôs not the case? How much weight does everyone feel then?</li>
  <li><strong><em>What Are YOU Doing?:</em></strong> This problem put stress patterns onto a particular structure (words in sentences), but that idea can be used in other contexts as well. What would music sound like if you emphasized certain notes and not others? Could you produce all the ways of pronouncing certain words by changing the stress patterns on the syllables?</li>
  <li><strong><em>Shift Scheduling:</em></strong> The discussion at the end of the shift scheduling problem points out a weakness in how that algorithm works. What changes might you make to the shift sched-uler to make it produce more stable schedules from week to week? How do you balance workers‚Äô needs for predictability with management‚Äôs goal of increasing profits?</li>
</ul>

<h2 id="general-notes">General Notes</h2>
<p>Here's some clarifications, notifications, expectations, and recommendations for this assignment.</p>
<ul>
  <li><strong><em>Your functions must actually use recursion;</em></strong> it defeats the point of the assignment to solve these problems iteratively! That being said, as you‚Äôll see in lecture next week, it‚Äôs perfectly alright for recursive functions to contain loops. The main question is whether your solution fundamentally works by breaking problems down into smaller copies of themselves. If so, great! If not, you may want to revisit your solution.</li>
  <li><strong><em>Test your code thoroughly!</em></strong> We‚Äôve included some test cases with the starter files, but they aren‚Äôt exhaustive. Be sure to add tests as you go!</li>
  <li><strong><em>Recursion can take some time to get used to,</em></strong> so don‚Äôt be dismayed if you can‚Äôt immediately sit down and solve these problems. We‚Äôve allowed you to work in pairs on this assignment so that you can discuss ideas with a partner, which can be a great way build an intuition for the concepts. Ask for advice and guidance if you need it. Once everything clicks, you‚Äôll have a much deeper understanding of just how cool a technique this is. We‚Äôre here to help you get there!</li>
</ul>

<h2 id="submission-instructions">Submission Instructions</h2>
<p>Once you've worked through the Assignment Submission Checklist and your code is ready to go, please submit the files <code class="language-c++ highlighter-rouge"><span class="n">Sierpinski</span><span class="p">.</span><span class="n">cpp</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">HumanPyramids</span><span class="p">.</span><span class="n">cpp</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">WhatAreYouDoing</span><span class="p">.</span><span class="n">cpp</span></code>, and <code class="language-c++ highlighter-rouge"><span class="n">ShiftScheduling</span><span class="p">.</span><span class="n">cpp</span></code> at <a href="https://paperless.stanford.edu/">https://paperless.stanford.edu</a>. If you edited any other files, please include them as well, but otherwise please just submit these four files. And that's it! You're done!</p>

<p><strong><em>Good luck, and have fun!</em></strong></p>
</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2020 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2021-Jan-29
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
