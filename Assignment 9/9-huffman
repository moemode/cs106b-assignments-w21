<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/class/cs106b/build/_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Huffman Coding</title>
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
   
    
    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Huffman Coding</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<><!-- This boilerplate inserts formatted due date -->

<!--  Boilerplate content for assignment index page -->

<h2 id="due-friday-march-19-at-1130-am-pacific">Due Friday, March 19 at 11:30 am Pacific</h2>

<ul>
  <li>Submissions received by due date receive a small <strong>on-time bonus</strong>.</li>
  <li>All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty.</li>
  <li>The <strong>grace period expires Sun, Mar 21 at 11:30 am Pacific</strong>, after which we cannot accept further late submissions.</li>
  <li>In this course, we express all date/times in <a href="https://www.timeanddate.com/worldclock/@5398563" title="Current time in Pacific">Pacific time GMT -8</a>. Our Paperless submission system also displays/records due dates and submission times in Pacific time.</li>
</ul>

<hr />

<p>Your final assignment of the quarter is to write a program that uses Huffman coding to compress and decompress files. It pulls together ideas from all over the quarter ‚Äì recursive exploration, linked structures, trees, and streaming algorithms. Once you‚Äôve finished coding this one up, you‚Äôll have a fairly impressive piece of software that‚Äôs powered by a bunch of clever algorithms. We hope this is a fitting capstone to your experience in CS106B!</p>

<div style="text-align: right;">
  <p><strong><em>Due Friday, March 19th at the start of lecture.</em></strong> <br />
<strong><em>You are welcome to work on this assignment in pairs.</em></strong></p>
</div>

<p>Here‚Äôs our recommended timetable for completing this assignment:</p>

<ul>
  <li>Work on the midterm over the weekend. Realistically, we don‚Äôt expect you to start this assignment until Monday.</li>
  <li>Aim to complete Milestone One on Monday.</li>
  <li>Aim to complete Milestone Two on Tuesday.</li>
  <li>Aim to complete Milestone Three on Wednesday.</li>
  <li>Aim to complete Milestone Four on Thursday.</li>
  <li>Bask in the glory of having completed the last assignment of the quarter, and explore Milestone Five on Thursday to appreciate the program you‚Äôve just written.</li>
</ul>

<h2 id="milestone-one-build-the-huffman-tree">Milestone One: Build the Huffman Tree</h2>
<p>In this first milestone, you‚Äôll implement this function:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="nf">huffmanTreeFor</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div></div>
<p>This function takes as input a piece of text, then builds a Huffman coding tree for that text using the algorithm from class. (It‚Äôs the one that makes a priority queue of a bunch of singleton nodes, then repeatedly combines nodes together.)</p>

<p>Before you code this up, take a minute to make sure you understand how Huffman coding works.</p>

<div class="keith-deliverables numbered-questions">
  <p>Edit the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code> with your answer to the following question:</p>

  <ol>
    <li>Draw the Huffman coding tree that would be produced for the input string <code class="language-c++ highlighter-rouge"><span class="s">"aabbbbccc"</span></code> by following the algorithm from class. One specific note: when merging trees together, structure your tree so that the first node removed from the priority queue becomes the 0 child of the tree and the second node removed from the priority queue becomes the 1 child of the tree.</li>
  </ol>
</div>

<p>Now, back to C++. The result of <code class="language-c++ highlighter-rouge"><span class="n">huffmanTreeFor</span></code> is a <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span><span class="o">*</span></code> object, where <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span></code> is defined as follows:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">EncodingTreeNode</span> <span class="p">{</span>                                     
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>                <span class="c1">// Which character is stored here.</span>
    <span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="n">zero</span><span class="p">;</span> <span class="c1">// Child tree labeled 0.          </span>
    <span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">;</span>  <span class="c1">// Child tree labeled 1.          </span>
<span class="p">};</span>               
</code></pre></div></div>

<p>The <code class="language-c++ highlighter-rouge"><span class="n">ch</span></code> variable here is only meaningful if the <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span></code> is a leaf node in the tree (do you see why?), so you should not read or write this variable in a <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span></code> unless that node is a leaf.</p>

<p>In the course of coding up this part of the assignment, you‚Äôll need to use a priority queue. You built one of these in Assignment 6, but that <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type was specifically designed to work with <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> objects. We‚Äôve provided the "<code class="language-c++ highlighter-rouge"><span class="n">priorityqueue</span><span class="p">.</span><span class="n">h</span></code>" header file, which defines a <code class="language-c++ highlighter-rouge"><span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> template that can store objects of any type. Consult the <a href="https://web.stanford.edu/class/cs106b/materials/library/documentation/">Stanford C++ Library Documentation</a> on the course website for more information about how to use this type. In particular, make sure you know how to enqueue and dequeue elements and how to determine the priorities of relevant items.</p>

<p>One little nuance that you‚Äôll need to be aware of: the test cases in the starter files we‚Äôve provided all assume that, when you‚Äôre running the Huffman tree construction algorithm, the first node you pull out of the queue will end up as the 0 child of the newly-constructed node, and the second node you pull out of the queue will end up as the 1 child. Make sure to follow this convention in this assignment.</p>

<p>To summarize, here‚Äôs what you need to do:</p>
<div class="keith-deliverables">
  <ol>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">huffmanTreeFor</span></code> function in Huffman.cpp.</li>
    <li>Add at least one custom test case for this function, and test your code thoroughly.</li>
  </ol>
</div>

<p>Our test coverage here is not as robust as in the previous assignments. You will need to test your code thoroughly. A recommendation: write a test case that creates a Huffman tree from a string of your choosing, then set a breakpoint and run the tests with the debugger on. Using the same techniques from Assignment 8 that you used to map out and escape the labyrinth, poke around in the debugger and draw out the trees that you‚Äôre producing. Do they match what you expected to find? If so, great! If not, step through your construction algorithm in the debugger and see what happens.</p>

<p>Some notes on this problem:</p>
<ul>
  <li>
    <p><strong><em>Do not edit the <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span></code> type</em></strong> when solving this problem. (More generally, don‚Äôt edit this type at any point in the assignment.)</p>
  </li>
  <li>
    <p>The tree construction algorithm we provided in class assumes that the input string has at least two different characters in it, and if this isn‚Äôt the case, your code should call the <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> function to report an error. (Do you see why the algorithm doesn‚Äôt work in these cases?)</p>
  </li>
  <li>
    <p>If multiple characters are tied for having the same weight, or if two or more intermediate trees are tied for having the same weight, you can break ties arbitrarily. Keep in mind that there can be many equally good Huffman trees for a given string, differing only in how the algorithm broke ties. As a result, if you‚Äôre writing custom test cases, make sure that your tests don‚Äôt assume anything about the specific way that the algorithm breaks ties when they arise.</p>
  </li>
  <li>
    <p>You should completely ignore the <code class="language-c++ highlighter-rouge"><span class="n">ch</span></code> field of <code class="language-c++ highlighter-rouge"><span class="n">EncodingTreeNode</span></code> for all nodes except leaves, the same way that you completely ignored the value field of the <code class="language-c++ highlighter-rouge"><span class="n">LinearProbingHashTable</span><span class="o">::</span><span class="n">Slot</span></code> type when the type field was set to <code class="language-c++ highlighter-rouge"><span class="n">SlotType</span><span class="o">::</span><span class="n">EMPTY</span></code>.</p>
  </li>
  <li>
    <p>You should be able to handle strings made of any characters, not just letters, numbers, etc. In particular, you can‚Äôt reserve certain char values to mean ‚Äúthis is an internal node.‚Äù Many files on disk ‚Äì especially files containing non-text data ‚Äì make use of all possible characters.</p>
  </li>
</ul>

<h2 id="milestone-two-implement-text-encoding-and-decoding">Milestone Two: Implement Text Encoding and Decoding</h2>
<p>Your next task is to write a pair of functions that are inverses of one another:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">string</span> <span class="nf">decodeText</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;&amp;</span> <span class="n">bits</span><span class="p">,</span>  <span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="n">tree</span><span class="p">);</span>
<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span> <span class="n">encodeText</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="n">tree</span><span class="p">);</span>
</code></pre></div></div>
<p>This <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> function takes as input a <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> representing some data that‚Äôs been compressed, along with a pointer to the encoding tree that was used, then returns the decompressed string. The <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> function takes as input a string and an encoding tree, then returns a <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> loaded with the bits formed by encoding that string using that tree.</p>

<p>Before you code this up, though, take a minute to make sure you know how to run the algorithms with a pencil and paper.</p>

<div class="keith-deliverables numbered-questions">
  <p>Edit the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code> with your answer to the following questions.</p>

  <ol>
    <li>Decode the string of bits <code class="language-c++ highlighter-rouge"><span class="mi">1100010011000100</span></code> using the encoding tree shown below:</li>
  </ol>

  <p class="text-center"><img src="img/milestone_2_encoding_tree.png" alt="A binary tree, where all left children represent a 0 bit and all right children represent a 1 bit. Only the leaf nodes have values, which are characters. The root node has child 0 (left child) A, and non-terminal child 1 (right child). This child has child 0 R, and non-terminal child 1. This child (2 levels down from root, root-1-1) has a non-terminal node at child 0 and child 1 B. Its child 0 (3 levels down from root, root-1-1-0, has child 0 C and child 1 D.)" /></p>

  <ol>
    <li>Encode the string <code class="language-c++ highlighter-rouge"><span class="n">ABRACADABRA</span></code> using the encoding tree from Q2.</li>
  </ol>
</div>

<p>Returning to C++ Land, you‚Äôll notice that these functions make reference to a <code class="language-c++ highlighter-rouge"><span class="n">Bit</span></code> type, which represents a single bit. The <code class="language-c++ highlighter-rouge"><span class="n">Bit</span></code> type works like a regular integer, though note that if you try assigning a value to a bit that isn‚Äôt a 0 or a 1 it‚Äôll report an error. For example:</p>
<div class="language-c++ nosyntaxerror highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bit</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                     
<span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>              
<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="err">‚Ä¶</span> <span class="p">}</span>
</code></pre></div></div>
<p>You can‚Äôt perform arithmetic on <code class="language-c++ highlighter-rouge"><span class="n">Bit</span></code>s. But that‚Äôs a good thing, because there‚Äôs no reason you should need to do that in this assignment. üòÉ</p>

<p>To summarize, here‚Äôs what you need to do:</p>
<div class="keith-deliverables">
  <ol>
    <li>Add a custom test case for the <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> function in <code class="language-c++ highlighter-rouge"><span class="n">Huffman</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> function and test thoroughly.</li>
    <li>Add a custom test case for the <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> function.</li>
    <li>Implement <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> and test thoroughly.</li>
  </ol>
</div>

<p>Some notes on this problem:</p>

<ul>
  <li>
    <p>You‚Äôre given the input <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code> by reference in <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code>, and your code can modify that <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code> however it feels like. The queue can end up empty, or could contain the original bits, or could contain whatever sequence of 0s and 1s that you‚Äôd like.</p>
  </li>
  <li>
    <p>In our initial examples of encoding and decoding text in lecture, we had access to an explicit table that represented the bit patterns associated with each character. It is <em>significantly</em> easier to implement the <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> function if you build a table like this before writing out the characters. However, having a table like that isn‚Äôt necessary for the <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> function ‚Äì do you see why?</p>
  </li>
  <li>
    <p>You can assume that the input tree is not null and doesn‚Äôt consist of just a single node. (These are the two degenerate cases that we said you didn‚Äôt need to handle in <code class="language-c++ highlighter-rouge"><span class="n">huffmanTreeFor</span></code>.)</p>
  </li>
  <li>
    <p>The tree given to <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> will always contain leaves holding all the characters that appear in the input string or input queue of bits (respectively), but may also contain other characters. The input tree does not necessarily have to be the optimal Huffman coding tree.</p>
  </li>
  <li>
    <p>You can assume that the bits provided to <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> form the correct encoding of a piece of text that was encoded using the same encoding tree that was provided to you. However, you should be careful about how you use this assumption. Specifically, if there‚Äôs a bug in your <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code>, then you may end up passing invalid bits into <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> ‚Äì oops! ‚Äì and so we recommend making your <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code> function as ‚Äúbulletproof‚Äù as possible by detecting and handling errors as you find them.</p>
  </li>
  <li>
    <p>In C++ there is a difference between the numbers <code class="language-c++ highlighter-rouge"><span class="mi">0</span></code> and <code class="language-c++ highlighter-rouge"><span class="mi">1</span></code> and the characters <code class="language-c++ highlighter-rouge"><span class="sc">'0'</span></code> and <code class="language-c++ highlighter-rouge"><span class="sc">'1'</span></code>. Be careful not to write something like</p>
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Bit</span> <span class="n">zero</span> <span class="o">=</span> <span class="sc">'0'</span><span class="p">;</span> <span class="c1">// Error!</span>
  <span class="n">Bit</span> <span class="n">one</span>  <span class="o">=</span> <span class="sc">'1'</span><span class="p">;</span> <span class="c1">// Error!</span>
</code></pre></div>    </div>
    <p>since this attempts to take the ASCII codes for <code class="language-c++ highlighter-rouge"><span class="sc">'0'</span></code> and <code class="language-c++ highlighter-rouge"><span class="sc">'1'</span></code> (namely, 48 and 49) as values for bits. Instead, use the numbers themselves:</p>
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Bit</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Beautiful!      </span>
  <span class="n">Bit</span> <span class="n">one</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Pulchritudinous!</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="milestone-three-implement-tree-encoding-and-decoding">Milestone Three: Implement Tree Encoding and Decoding</h2>
<p>One of the practical concerns of Huffman coding that we discussed in class is that if you do choose to use Huffman coding, you need to somehow store information about which encoding tree you used. That way, whoever is decoding the information knows which codes corresponding to which characters. This means that we‚Äôll need to devise a pair of functions that allow you to take a tree and encode it in a way that can be stored on disk, plus a way to decode the encoded representation back into the tree.</p>

<p>There are many ways to do this, but one of the most space-efficient ways is the following. We‚Äôll encode each tree as a pair of a <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> representing the shape of the tree and a <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code> representing which characters are in the leaves of the tree. The shape of the tree is encoded as follows:</p>
<ul>
  <li>If the tree is a single leaf node, it‚Äôs represented by the bit 0.</li>
  <li>If the tree is not a leaf node, it‚Äôs represented by a 1 bit, followed by the encoding of its zero (left)
subtree, followed by the encoding of its one (right) subtree.</li>
</ul>

<p>The <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code> representing which characters are stored in the leaves of the tree is found by reading the leaves in the pattern you‚Äôd get by doing an inorder traversal of the tree. For example, here are several Huffman trees and how they‚Äôd be represented as a sequence of bits and a sequence of characters:</p>

<div style="display: flex; flex-wrap: wrap; justify-content: space-around">
  <p><img src="img/mil3_1.png" alt="10100 encodes to EWK. The Huffman tree is as follows: From the root node, the 0 path leads to E, and the 1 path leads to another node (without a letter). From that node, the 0 path leads to W and the 1 path leads to K." /></p>

  <p><img src="img/mil3_2.png" alt="1011000 encodes to ADBN. The Huffman tree is as follows: From the root node, the 0 path leads to A, and the 1 path leads to another node (without a letter). From that node, the 1 path leads to N, and the 0 path leads to another node (without a letter). From that node, the 0 path leads to D and the 1 path leads to B." /></p>

  <p><img src="img/mil3_3.png" alt="11001100100 encodes to ANIVCE. The Huffman tree is as follows: From the root node: 00 encodes to A, while 01 encodes to N. 100 encodes to I, while 101 encodes to V. 110 encodes to C, while 111 encodes to E." /></p>
</div>

<p>This is an extremely compact way of writing out a tree: the tree itself is written out with one bit per node, and the contents of the leaves are written out as-is. Most importantly, it‚Äôs possible to reverse the encoding back into a tree. Before writing code to compute or process these sequences, grab a pencil and paper and make sure you‚Äôre comfortable with how these work.</p>

<p>Edit the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code> with your answers to the following questions.</p>

<div class="keith-deliverables numbered-questions">
  <ol>
    <li>Write out the <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code> associated with this encoding tree:</li>
  </ol>

  <p class="text-center"><img src="img/mil3_4.png" alt="The Huffman tree is as follows: The path 00 leads to O, the path 01 leads to E. 100 leads to oA, 101 lead to P, and 11 leads to H." /></p>

  <ol>
    <li>Decode this <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code>into an encoding tree and draw the result:
      <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">111000100</span>
<span class="n">MDCLV</span>
</code></pre></div>      </div>
    </li>
  </ol>
</div>

<p>Your task in this part of the assignment is to write a pair of functions</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">encodeTree</span><span class="p">(</span><span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;&amp;</span> <span class="n">bits</span><span class="p">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">leaves</span><span class="p">);</span>
<span class="n">EncodingTreeNode</span><span class="o">*</span> <span class="nf">decodeTree</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;&amp;</span> <span class="n">bits</span><span class="p">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">leaves</span><span class="p">);</span>
</code></pre></div></div>
<p>This first function takes a tree and produces the two <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>s shown above. The second function takes in the two <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>s and reconstructs the tree they represent.</p>

<p>Specifically, you should do the following:</p>

<div class="keith-deliverables">
  <ol>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">encodeTree</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">decodeTree</span></code> functions in <code class="language-c++ highlighter-rouge"><span class="n">Huffman</span><span class="p">.</span><span class="n">cpp</span><span class="p">.</span></code></li>
    <li>Add at least two custom test cases, one for each function, and test your code thoroughly.</li>
  </ol>
</div>

<p>Some notes on this problem:</p>

<ul>
  <li>
    <p>There are no requirements about what the <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code> should contain after <code class="language-c++ highlighter-rouge"><span class="n">decodeTree</span></code> finishes running. They could be unchanged, or completely empty, or filled with whatever contents you‚Äôd like.</p>
  </li>
  <li>
    <p>You can assume the inputs to <code class="language-c++ highlighter-rouge"><span class="n">decodeTree</span></code> are correct, in that the bits and characters are a correct representation of some encoding tree, that there aren‚Äôt stray bits in the queue, that you have the exact correct number of characters that you need, etc. However, as with <code class="language-c++ highlighter-rouge"><span class="n">encodeText</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">decodeText</span></code>, a bug in your implementation of <code class="language-c++ highlighter-rouge"><span class="n">encodeTree</span></code> may manifest as errors in <code class="language-c++ highlighter-rouge"><span class="n">decodeTree</span></code>, so we recommend making your <code class="language-c++ highlighter-rouge"><span class="n">decodeTree</span></code> function ‚Äúrobust‚Äù and able to identify and flag errors if it finds them.</p>
  </li>
  <li>
    <p>You can assume the tree provided as input to <code class="language-c++ highlighter-rouge"><span class="n">encodeTree</span></code> is a valid coding tree ‚Äì each internal node will have exactly two children, only the characters in the leaves matter, each character appears in at most one leaf, etc.</p>
  </li>
  <li>
    <p>You can assume the input <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code> to <code class="language-c++ highlighter-rouge"><span class="n">encodeTree</span></code> are empty when that function is first called.</p>
  </li>
  <li>
    <p>You don‚Äôt need to worry about the edge cases that came up in the first milestone. You can assume the tree exists and contains at least two leaves.</p>
  </li>
</ul>

<h2 id="milestone-four-put-it-all-together">Milestone Four: Put It All Together</h2>

<p>You now have all the pieces you need to build the final Huffman encoder and decoder. Implement the following pair of functions:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HuffmanResult</span> <span class="nf">compress</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">decompress</span><span class="p">(</span><span class="n">HuffmanResult</span><span class="o">&amp;</span> <span class="n">file</span><span class="p">);</span>
</code></pre></div></div>

<p>This first function takes as input a string of text and produces a <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> containing all the information necessary to store the compressed contents of that string to disk. The second function takes as input a compressed <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> and returns the string that it encodes. Here, the <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> type represents a combination of the encoded tree and the encoded text:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">HuffmanResult</span> <span class="p">{</span>                        
    <span class="cm">/* Encoded version of the Huffman tree. */</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span>  <span class="n">treeBits</span><span class="p">;</span>                     
    <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">treeLeaves</span><span class="p">;</span>                   
 
    <span class="cm">/* Encoded version of the message. */</span>     
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Bit</span><span class="o">&gt;</span> <span class="n">messageBits</span><span class="p">;</span>                   
<span class="p">};</span>
</code></pre></div></div>
<p>This section should mostly consist of putting together the different pieces you wrote earlier in the right order. In doing so, you may discover that there were some bugs lurking in your implementation, which you‚Äôll need to then correct to get everything working. (It‚Äôs common in software engineering to find that each individual piece of a program passes its tests independently but fails when things come together; it‚Äôs usually either due to tests not covering every possible case or to some unexpected interactions between the components). When that happens, use the debugger to isolate where the issue is. Did you build the encoding tree incorrectly? Did you encode the message bits wrong, or is the issue in the decoder?</p>

<p>To summarize, here‚Äôs what you need to do:</p>

<ol class="keith-deliverables">
  <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">compress</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">decompress</span></code> functions in <code class="language-c++ highlighter-rouge"><span class="n">Huffman</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
  <li>Add at least one custom test case to ensure that your code works. Take this step seriously ‚Äì writing good tests here will help you identify and smoke out errors that might be lurking in your code.</li>
</ol>

<p>Testing is key here! We have not provided enough tests with the starter files to poke and prod these functions in all the ways they can be poked and prodded, and you should not consider your implementation to be ready until you‚Äôve written some tests of your own and used the interactive ‚ÄúCompress a File‚Äù and ‚ÄúDecompress a File‚Äù options to confirm that your code works end-to-end.</p>

<p>Some notes on this part of the assignment:</p>
<ul>
  <li>Your implementation should call <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> if the input string to compress doesn‚Äôt have at least two distinct characters in it.</li>
  <li>You can assume that the input to <code class="language-c++ highlighter-rouge"><span class="n">decompress</span><span class="p">()</span></code> is a valid compressed file and don‚Äôt need to worry about what happens if this isn‚Äôt the case. Then again, making this function as robust as possible is a <em>great</em> idea during testing.</li>
  <li>Our provided starter files contain logic to take a <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> and save it to disk and to take a <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> and load it from disk. The internal logic of how this works is more of a CS107-level topic that involves manipulating individual bits of variables, which is beyond the scope of what we‚Äôre going to cover in CS106B. However, if you‚Äôre curious to see how this works, you‚Äôre welcome to check out <code class="language-c++ highlighter-rouge"><span class="n">Demos</span><span class="o">/</span><span class="n">HuffmanResult</span><span class="p">.</span><span class="n">cpp</span></code> to learn more!</li>
  <li>Make sure not to leak any memory in your implementations.</li>
  <li>There are no requirements about what the final contents of the <code class="language-c++ highlighter-rouge"><span class="n">HuffmanResult</span></code> may be after calling decompress. You can leave it unchanged, empty it out, etc.</li>
</ul>

<h2 id="milestone-five-enjoy-your-creation">Milestone Five: Enjoy Your Creation!</h2>

<p>Congratulations! You‚Äôve just built a compression and decompression algorithm! All that‚Äôs left to do now is to try it out on a few examples to see how well it does.
We‚Äôve bundled a number of sample files with the assignment, some already compressed (they have the suffix <code class="language-c++ highlighter-rouge"><span class="p">.</span><span class="n">huff</span></code>) and some not yet compressed. Use your program to decompress the compressed files to see what they contain, and then try compressing some of the sample files so that you can see how well those files compress!</p>

<p>Try decompressing the file <code class="language-c++ highlighter-rouge"><span class="n">samples</span><span class="o">/</span><span class="n">Congratulations</span><span class="p">.</span><span class="n">bmp</span><span class="p">.</span><span class="n">huff</span></code>. That file will expand out to one named <code class="language-c++ highlighter-rouge"><span class="n">Congratulations</span><span class="p">.</span><span class="n">bmp</span></code>, which you should definitely take a look at once you‚Äôve finished the assignment. The same is true for the file <code class="language-c++ highlighter-rouge"><span class="n">samples</span><span class="o">/</span><span class="n">Woohoo</span><span class="o">!</span><span class="p">.</span><span class="n">mp4</span><span class="p">.</span><span class="n">huff</span></code>. üòÉ</p>

<p class="keith-deliverables">There are no deliverables for this section. Just play around and see what you find!</p>

<h2 id="optional-milestone-six-extensions">(Optional) Milestone Six: Extensions!</h2>
<p>If you enjoyed this assignment and want to run further with it, we‚Äôd love to see what you come up with! Here are a few suggestions to help you get started.</p>

<ul>
  <li><strong><em>Implement a more advanced compression algorithm.</em></strong> Huffman coding is a good compression algorithm, but there are better alternatives in many cases. Many modern compression algorithms are based on an algorithm called LZW, named after the initials of its inventors. Other topics to look up include move-to-front coding, run-length encoding, and the Burrows-Wheeler transform.</li>
  <li><strong><em>Explore some information theory.</em></strong> The field of information theory explores, among other things, the limits of data compression, and gives ways of measuring how good particular compression algorithms are. Look up Shannon entropy, KL divergence, and other similar concepts and see if you can use them to tell us anything interesting about data compression.</li>
</ul>

<h2 id="submission-instructions">Submission Instructions</h2>
<p>Once you‚Äôve autoindented your code so that it looks beautiful and worked through the Assignment Submission Checklist, submit the following files on Paperless, plus any other files you modified when writing up extensions:</p>

<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>. <strong><em>(Don‚Äôt forget this one, even though there‚Äôs no code in it!)</em></strong></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">Huffman</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
</ul>

<p>And that‚Äôs it! You‚Äôre done! You know how to work with trees, linked structures, container types, and recursive problem-solving. Congratulations!</p>

<div class="keith-callout">
<div>
<div style="margin-bottom: 5px">Congratulations on finishing the last assignment of the quarter!</div>
We‚Äôre extremely impressed with how much progress you‚Äôve made
since the start of the quarter. Best of luck going forward!
</div>
</div>
</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2020 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2021-Mar-12
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
