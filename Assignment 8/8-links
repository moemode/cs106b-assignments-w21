<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/class/cs106b/build/_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B The Adventures of Links</title>
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
   
    
    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">The Adventures of Links</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<><!-- This boilerplate inserts formatted due date -->

<!--  Boilerplate content for assignment index page -->

<h2 id="due-friday-march-12-at-1130-am-pacific">Due Friday, March 12 at 11:30 am Pacific</h2>

<ul>
  <li>Submissions received by due date receive a small <strong>on-time bonus</strong>.</li>
  <li>All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty.</li>
  <li>The <strong>grace period expires Sun, Mar 14 at 12:30 pm Pacific</strong>, after which we cannot accept further late submissions.</li>
  <li>In this course, we express all date/times in <a href="https://www.timeanddate.com/worldclock/@5398563" title="Current time in Pacific">Pacific time GMT -8</a>. Our Paperless submission system also displays/records due dates and submission times in Pacific time.</li>
</ul>

<hr />

<!-- Include the below since they're shared between the main and console version. -->
<p>Linked structures are a fundamentally different way of encoding sequences than the array-based approaches you worked with on Assignment 6 and Assignment 7. This assignment is all about manipulating, traversing, and exploring linked structures. It‚Äôs a two-parter. The first part is a hybrid coding/debugging exercise where you‚Äôll work the debugger to escape from a maze. The second part is a coding exercise in which you‚Äôll use linked lists to manipulate DNA sequences.</p>

<p><strong><em>Due Friday, March 12th at 11:30AM.</em></strong>
<strong><em>You are welcome to work in pairs on this assignment.</em></strong></p>

<p>You know the drill ‚Äì make consistent, slow, steady progress on this assignment rather than doing everything at the last minute. Here‚Äôs our recommended timeline:</p>
<ul>
  <li>Aim to complete The Labyrinth! within two days of this assignment going out.</li>
  <li>Aim to complete Splicing and Dicing within seven days of this assignment going out.</li>
</ul>

<h2 id="problem-one-the-labyrinth">Problem One: The Labyrinth!</h2>
<p>You have been trapped in a labyrinth, and your only hope to escape is to cast the magic spell that will free you from its walls. To do so, you will need to explore the labyrinth to find three magical items:</p>
<ul>
  <li>The <strong><em>Spellbook</em></strong> (üìï), which contains the spell you need to cast to escape.</li>
  <li>The <strong><em>Potion</em></strong> (‚öó), containing the arcane compounds that power the spell.</li>
  <li>The <strong><em>Wand</em></strong> (‚öö), which concentrates your focus to make the spell work.
Once you have all three items, you can cast the spell to escape to safety.</li>
</ul>

<p>This is, of course, no ordinary maze. It‚Äôs a <strong><em>pointer maze</em></strong>. The maze consists of a collection of objects of type <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>, where <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> is defined here:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="nc">MazeCell</span> <span class="p">{</span>                                                              
    <span class="n">Item</span> <span class="n">whatsHere</span><span class="p">;</span>  <span class="c1">// Item present, if any.                                  </span>
    <span class="n">MazeCell</span><span class="o">*</span> <span class="n">north</span><span class="p">;</span> <span class="c1">// The cell north of us, or nullptr if we can't go north.</span>
    <span class="n">MazeCell</span><span class="o">*</span> <span class="n">south</span><span class="p">;</span>                                                           
    <span class="n">MazeCell</span><span class="o">*</span> <span class="n">east</span><span class="p">;</span>                                                            
    <span class="n">MazeCell</span><span class="o">*</span> <span class="n">west</span><span class="p">;</span>                                                            
<span class="p">};</span>                                                                             
</code></pre></div></div>

<p>Here, <code class="language-c++ highlighter-rouge"><span class="n">Item</span></code> is this enumerated type:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>                   
    <span class="n">NOTHING</span><span class="p">,</span> <span class="n">SPELLBOOK</span><span class="p">,</span> <span class="n">POTION</span><span class="p">,</span> <span class="n">WAND</span>
<span class="p">};</span>            
</code></pre></div></div>

<p>For example, here is a 4 √ó 4 labyrinth.
<img src="img/labyrinth.png" alt="4 x 4 grid of cells, where some cells are connected by double-headed arrow pointers. The third cell in the top row has a wand in it, the first cell in the third row has a spellbook in it, the third cell in the third row has a smiley face in it (that's you!), and the fourth cell in the fourth row has a potion in it. The cell with the book is connected via a double-headed arrow only to the cell below it. The cell you (smiley face) are in has 4 pointers on each face of the cell, to cells above, below, left, and right." />
We‚Äôve marked your starting position with a smiley face and the positions of of the three items with similarly cute emojis. The <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> you begin at would have its north, south, east, and west pointers pointing at the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> objects located one step in each of those directions from you. On the other hand, the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> containing the book would have its north, east, and west pointers set to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, and only its south pointer would point somewhere (specifically, to the cell in the bottom-left corner).</p>

<p>Each <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> has a variable named <code class="language-c++ highlighter-rouge"><span class="n">whatsHere</span></code> that indicates what item, if any, is at that position. Empty cells will have <code class="language-c++ highlighter-rouge"><span class="n">whatsHere</span></code> set to the <code class="language-c++ highlighter-rouge"><span class="n">Item</span><span class="o">::</span><span class="n">NOTHING</span></code>. The cells containing the Spellbook, Potion, or Wand will have those fields set to <code class="language-c++ highlighter-rouge"><span class="n">Item</span><span class="o">::</span><span class="n">SPELLBOOK</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Item</span><span class="o">::</span><span class="n">POTION</span></code>, or <code class="language-c++ highlighter-rouge"><span class="n">Item</span><span class="o">::</span><span class="n">WAND</span></code>, respectively.</p>

<p>If you were to find yourself in this labyrinth, you could walk around a bit to find the items you need to cast the escape spell. There are many paths you can take; here‚Äôs three of them:
<code class="language-c++ highlighter-rouge"><span class="n">ESNWWNNEWSSESWWN</span></code>
<code class="language-c++ highlighter-rouge"><span class="n">SWWNSEENWNNEWSSEES</span></code>
<code class="language-c++ highlighter-rouge"><span class="n">WNNEWSSESWWNSEENES</span></code></p>

<p>Each path is represented as a sequence of letters (N for north, W for west, etc.) that, when followed from left to right, trace out the directions you‚Äôd follow. For example, the first sequence represents going east, then south (getting the Potion), then north, then west, etc. Trace though those paths and make sure you see how they pick up all three items.</p>

<p>There are three milestones to this problem. The first one is a coding problem, and the second two are debugger exercises. We strongly recommend completing them in the order in which they appear, as they build on top of one another.</p>

<h3 id="milestone-1-check-paths-to-freedom">Milestone 1: Check Paths to Freedom</h3>
<p>Your first task is to write a function that, given a cell in a maze and a path, checks whether that path is legal and picks up all three items. Specifically, in the file <code class="language-c++ highlighter-rouge"><span class="n">Labyrinth</span><span class="p">.</span><span class="n">cpp</span></code>, implement the function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isPathToFreedom</span><span class="p">(</span><span class="n">MazeCell</span><span class="o">*</span> <span class="n">startLocation</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">);</span>
</code></pre></div></div>
<p>This function takes as input your starting location in the maze and a string made purely from the characters 'N', 'S', 'E', and 'W', then returns whether that path lets you escape from the maze.</p>

<p>A path lets you escape the maze if (1) the path is legal, in the sense that it never takes a step that isn‚Äôt permitted in the current <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>, and (2) the path picks up the Spellbook, Wand, and Potion. The order in which those items are picked up is irrelevant, and it‚Äôs okay if the path continues onward after picking all the items up.</p>

<p>You can assume that <code class="language-c++ highlighter-rouge"><span class="n">startLocation</span></code> is not a null pointer (you do indeed begin somewhere) and that the input string does not contain any characters besides 'N', 'S', 'E', and 'W' and do not need to handle the case where this isn‚Äôt true.</p>

<p>To summarize, here‚Äôs what you need to do.</p>
<div class="keith-deliverables">
  <ol>
    <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">isPathToFreedom</span></code> function in <code class="language-c++ highlighter-rouge"><span class="n">Labyrinth</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
    <li>Test your code thoroughly using our provided tests. (If you‚Äôd like to write tests of your own, you‚Äôre welcome to do so, though it‚Äôs not required here.)</li>
  </ol>
</div>

<p>Some notes on this problem:</p>
<ul>
  <li>Your code should work for a <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> from any possible maze, not just the one shown on the previous page.</li>
  <li>Although in the previous picture the maze was structured so that if there was a link from one cell to another going north there would always be a link from the second cell back to the first going south (and the same for east/west links), you should <em>not</em> assume this is the case in this function. Then again, chances are you wouldn‚Äôt need to assume this.</li>
  <li>A path might visit the same location multiple times, including possibly visiting locations with items in them multiple times.</li>
  <li>You shouldn‚Äôt need to allocate any new <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> objects in the course of solving this problem. Feel free to declare variables of type <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span><span class="o">*</span></code>, but don‚Äôt use the new keyword. After all, your job is to check a path in an existing maze, not to make a new maze.</li>
  <li>Feel free to implement this function either iteratively or recursively, whichever seems best to you. You don‚Äôt need to worry about stack overflows here; we‚Äôll never run your code on anything large enough to run out of stack space.</li>
  <li>Your code should not modify the maze passed into the function. In particular, you should not change which items appear where or where the links point.</li>
  <li>An edge case you should handle: it is okay to find the three items and then continue to walk around the maze. However, if the path both (1) finds all three items and (2) tries making an illegal step, then your function should return false.</li>
</ul>

<h3 id="milestone-2-escape-from-your-personal-labyrinth">Milestone 2: Escape from Your Personal Labyrinth</h3>
<p>Your next task is to escape from a labyrinth that‚Äôs specifically constructed for you (and your partner, if you‚Äôre working in a pair). The starter code we‚Äôve provided will use your name(s) to build you a personalized labyrinth. By ‚Äúpersonalized,‚Äù we mean ‚Äúno one else in the course is going to have the exact same labyrinth as you.‚Äù Your job is to figure out a path through that labyrinth that picks up all the three items, allowing you to escape.</p>

<p>Open the file <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code> and you‚Äôll see three constants. The first one, <code class="language-c++ highlighter-rouge"><span class="n">MyName</span></code>, is a spot for your name (or your name and your partner‚Äôs name, if you‚Äôre working in a pair). Right now, it‚Äôs marked with a <code class="language-c++ highlighter-rouge"><span class="n">TODO</span></code> message. Edit this constant so that it contains your name(s).</p>

<p>Scroll down to the <strong><em>first</em></strong> test case in <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code>. This test case generates a personalized labyrinth based on the <code class="language-c++ highlighter-rouge"><span class="n">MyName</span></code> constant and returns a pointer to one of the cells in that maze. It then checks whether the constant <code class="language-c++ highlighter-rouge"><span class="n">ThePathOutOfMyMaze</span></code> is a sequence that will let you escape from the maze. Right now, <code class="language-c++ highlighter-rouge"><span class="n">ThePathOutOfMyMaze</span></code> is a <code class="language-c++ highlighter-rouge"><span class="n">TODO</span></code> message, so it‚Äôs not going to let you escape from the labyrinth. You‚Äôll need to edit this string with the escape sequence once you find it.</p>

<p>To come up with a path out of the labyrinth, use the debugger! Set a breakpoint at the indicated line in the <strong><em>first</em></strong> test case. Launch the demo app with the debugger enabled. When you do, you should see the local variables window pop up, along with the contents of <code class="language-c++ highlighter-rouge"><span class="n">startLocation</span></code>, which is the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> where we‚Äôve dropped you into the labyrinth. Clicking the dropdown triangle in the debugger window will let you read the contents of the <code class="language-c++ highlighter-rouge"><span class="n">whatsHere</span></code> field of startLocation (it‚Äôll be <code class="language-c++ highlighter-rouge"><span class="n">Item</span><span class="o">::</span><span class="n">NOTHING</span></code>), as well as the four pointers leading out of the cell.</p>

<p>Depending on your maze, you may find yourself in a position where you can move in all four cardinal directions, or you may find that you can only move in some of them. The pointers in directions you can‚Äôt go are all equal to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, which will show up as <code class="language-c++ highlighter-rouge"><span class="mh">0x0</span></code> in the debugger window. The pointers that indicate directions you can go will all have dropdown arrows near them. Clicking one of these arrows will show you the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>s reachable by moving in the indicated directions. You can navigate the maze further by choosing one of those dropdown arrows, or you could back up to the starting maze cell and explore in other directions. It‚Äôs really up to you!</p>

<p>Draw a lot of pictures. Grab a sheet of paper and map out the maze you‚Äôre in. There‚Äôs no guarantee where you begin in the maze ‚Äì you could be in the upper-left corner, dead center, etc. The items are scattered randomly, and you‚Äôll need to seek them out. Once you‚Äôve mapped out the maze, construct an escape sequence and stash it in the constant <code class="language-c++ highlighter-rouge"><span class="n">ThePathOutOfMyMaze</span></code>, then see if you pass the first test. If so, fantastic! You‚Äôve escaped! If not, you have lots of options. You could step through your <code class="language-c++ highlighter-rouge"><span class="n">isPathToFreedom</span></code> function to see if one of the letters you entered isn‚Äôt what you intended and accidentally tries to move in an illegal direction. Or perhaps the issue is that you misdrew your map and you‚Äôve ended up somewhere without all the items. You could alternatively set the breakpoint at the test case again and walk through things a second time, seeing whether the picture of the maze you drew was incorrect.</p>

<p>To summarize, here‚Äôs what you need to do:</p>
<div class="keith-deliverables">
  <ol>
    <li>Edit the constant <code class="language-c++ highlighter-rouge"><span class="n">MyName</span></code> at the top of <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code> with a string containing your name and your partner‚Äôs name if you‚Äôre working in a group. Don‚Äôt skip this step! If you forget to do this, you‚Äôll be solving the wrong maze!</li>
    <li>Set a breakpoint at the indicated line in the first test case in <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code>, run the program in debug mode, and choose ‚ÄúRun Tests‚Äù to activate the breakpoint.</li>
    <li>Map out the maze on a sheet of paper and find where all the items are. Once you‚Äôre done, stop the running program.</li>
    <li>Find a path that picks up all three items and edit the constant <code class="language-c++ highlighter-rouge"><span class="n">ThePathOutOfMyMaze</span></code> at the top of <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code> with that path. Run the test a second time with the debugger turned off to confirm you‚Äôve escaped.</li>
  </ol>
</div>

<h3 id="milestone-3-escape-from-your-personal-twisty-labyrinth">Milestone 3: Escape from Your Personal Twisty Labyrinth</h3>
<p>Now, let‚Äôs make things a bit more interesting. In the previous section, you escaped from a labyrinth that nicely obeyed the laws of geometry. The locations you visited formed a nice grid, any time you went north you could then go back south, etc.</p>

<p>In this section, we‚Äôre going to relax these constraints, and you‚Äôll need to find your way out of trickier mazes that look like this one:
<img src="img/twisty_labyrinth.png" alt="Labyrinth with cells that aren't in a full rectangular grid -- some cells are connected to cells that don't directly neighbor them. Here, pointers are only drawn in one direction, and the cardinal directions no longer mean what they usually do. Wacky!" /></p>

<p>This maze is stranger than the previous one you explored. For example, you‚Äôll notice that these <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>s are no longer in a nice rectangular grid where directions of motion correspond to the natural cardinal directions. There‚Äôs a <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> here where moving north and then north again will take you back where you started. In one spot, if you move west, you have to move south to return to where you used to be. In that sense, the names ‚Äúnorth,‚Äù ‚Äúsouth,‚Äù ‚Äúeast,‚Äù and ‚Äúwest‚Äù here no longer have any nice geometric meaning; they‚Äôre just the names of four possible exits from one <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> into another.</p>

<p>The one guarantee you do have is that if you move from one <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> to a second, there will always be a direct link from the second cell back to the first. It just might be along a direction of travel that has no relation to any of the directions you‚Äôve taken so far.</p>

<p>The <strong><em>second</em></strong> test case in <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code> contains code that generates a twisty labyrinth personalized with the <code class="language-c++ highlighter-rouge"><span class="n">MyName</span></code> constant. As before, you‚Äôll need to find a sequence of steps that will let you collect the three items you need to escape.</p>

<p>In many regards, the way to complete this section is similar to the way to complete the previous one. Set a breakpoint in the indicated spot in the second test case and use the debugger to explore the maze. Unlike the previous section, though, in this case you can‚Äôt rely on your intuition for what the geometry of the maze will look like. For example, suppose your starting location allows you to go north. You might find yourself in a cell where you can then move either east or west. One of those directions will take you back where you started, but how would you know which one?</p>

<p>This is where memory addresses come in. Internally, each object in C++ has a <strong><em>memory address</em></strong> associated with it. Memory addresses typically are written out in the form @0x<strong><em>something</em></strong>, where something is the address of the object. You can think of memory addresses as sort of being like an ‚ÄúID number‚Äù for an object ‚Äì each object has a unique address, with no two objects having the same address. When you pull up the debugger view of a maze cell, you should see the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> memory address under the Value column.</p>

<p>For example, suppose that you‚Äôre in a maze and your starting location has address <code class="language-c++ highlighter-rouge"><span class="mh">0x7fffc8003740</span></code> (the actual number you see will vary based on your OS), and you can move to the south (which ways you can go are personalized to you based on your name, so you may have some other direction to move). If you expand out the dropdown for the south pointer, you‚Äôll find yourself at some other MazeCell. One of the links out of that cell takes you back where you‚Äôve started, and it‚Äôll be labeled <code class="language-c++ highlighter-rouge"><span class="mh">0x7fffc8003740</span></code>. Moving in that direction might not be productive ‚Äì it just takes you back where you came from ‚Äì so you‚Äôd probably want to explore other directions to search the maze.</p>

<p>It‚Äôs going to be hard to escape from your maze unless you <strong><em>draw lots of pictures</em></strong> to map out your surroundings. To trace out the maze that you‚Äôll be exploring, we recommend diagramming it on a sheet of paper as follows. For each <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>, draw a circle labeled with the memory address, or, at least the last five characters of that memory address. (Usually, that‚Äôs sufficient to identify which object you‚Äôre looking at). As you explore, add arrows between those circles labeled with which direction those arrows correspond to. What you have should look like the picture above, except that each circle will be annotated with a memory address. It‚Äôll take some time and patience, but with not too much effort you should be able to scout out the full maze. Then, as before, find an escape sequence from the maze!</p>

<p>To recap, here's what you need to do:</p>
<div class="keith-deliverables">
  <ol>
    <li>Set a breakpoint at the indicated line in the second test case in <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code>, run the demo app in debug mode and choose ‚ÄúRun Tests‚Äù to activate the breakpoint.</li>
    <li>Map out the twisty maze on a sheet of paper and find where all the items are and how the cells link to each other. Once you‚Äôre done, stop the running program.</li>
    <li>Find an escape sequence, and edit the constant <code class="language-c++ highlighter-rouge"><span class="n">ThePathOutOfMyTwistyMaze</span></code> at the top of <code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span></code> with that constant. Run the tests again ‚Äì this time without the breakpoint ‚Äì and see if you‚Äôve managed to escape!</li>
  </ol>
</div>

<p>Some notes on this problem:</p>
<ul>
  <li><strong><em>The memory addresses of objects are not guaranteed to be consistent across runs of the program.</em></strong> This means that if you map out your maze, stop the running program, and then start the program back up again, you are <strong><em>not</em></strong> guaranteed that the addresses of the <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>s in the maze will be the same. The <em>shape</em> of the maze is guaranteed to be the same, though. If you do close your program and then need to explore the maze again, you may need to relabel your circles as you go, but you won‚Äôt be drawing a different set of circles or changing where the arrows link.</li>
  <li>You are guaranteed that if you follow a link from one <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> to another, there will always be a link from that second <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> back to the first, though the particular directions of those links might be completely arbitrary. That is, you‚Äôll never get ‚Äútrapped‚Äù somewhere where you can move one direction but not back where you started.</li>
  <li>Attention to detail is key here ‚Äì different <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code> objects will always have different addresses, but those addresses might be really similar to one another. Make sure that as you‚Äôre drawing out your diagram of the maze, you don‚Äôt include duplicate copies of the same <code class="language-c++ highlighter-rouge"><span class="n">MazeCell</span></code>.</li>
  <li>The maze you‚Äôre exploring might contain loops or cases where there are multiple distinct paths between different locations. Keep this in mind as you‚Äôre exploring or you might find yourself going in circles!</li>
  <li>Remember that you don‚Äôt necessarily need to map out the whole maze. You only need to explore enough of it to find the three items and form a path that picks all of them up.</li>
</ul>

<p>At this point, you have a solid command of how to use the debugger to analyze linked structures. You know how to recognize a null pointer, how to manually follow links between objects, and how to reconstruct the full shape of the linked structure even when there‚Äôs bizarre and unpredicable cross-links between them. We hope you find these skills useful as you continue to write code that works on linked lists and other linked structures!</p>

<h2 id="problem-two-splicing-and-dicing">Problem Two: Splicing and Dicing</h2>
<p>DNA strands are made up of smaller units called <em>nucleotides</em>. There are four different nucleotides present in DNA, which are represented by the letters A, C, G, and T. Any DNA strand, therefore, can be thought of as linked structure consisting of the nucleotides that make up that strand, in order. In software, we might represent a nucleotide as a doubly-linked list made of individual units that look like this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Nucleotide</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// 'A', 'C', 'G', or 'T' </span>
  <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>For example, the DNA sequence <code class="language-c++ highlighter-rouge"><span class="n">TAGCAT</span></code> would be represented as follows:
<img src="img/DNA_1.png" alt="DNA sequence is connected as follows: TAGCAT" />
Although they aren‚Äôt pictured here, the <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointer of the first <code class="language-c++ highlighter-rouge"><span class="n">T</span></code> and the next pointer of the last <code class="language-c++ highlighter-rouge"><span class="n">T</span></code> would each be set to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>. For visual simplicity, we‚Äôre going to leave those pointers out of future pictures as well, but it doesn‚Äôt hurt to draw them in!
There are four milestones in this part of the assignment, and they‚Äôre spelled out over the next pages.</p>

<h3 id="milestone-one-implement-core-functions">Milestone One: Implement Core Functions</h3>
<p>Your first task is to write functions for manipulating existing DNA sequences. First, write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteNucleotides</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*</span> <span class="n">dna</span><span class="p">);</span>
</code></pre></div></div>
<p>that takes as input a pointer to a DNA strand, then deletes all the memory used by the nucleotides in that strand. It‚Äôs possible that the input pointer is <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code> if the DNA strand is empty, in which case this function should do nothing.
Next, write this function:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">fromDNA</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*</span> <span class="n">dna</span><span class="p">);</span>
</code></pre></div></div>
<p>This function takes as input a sequence of nucleotides, then returns a string representation of the DNA strand. For example, calling <code class="language-c++ highlighter-rouge"><span class="n">fromDNA</span></code> on the <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> pointer shown below would return <code class="language-c++ highlighter-rouge"><span class="s">"GTTCAGT"</span></code>:
<img src="img/DNA_2.png" alt="The dna points points to the first node in the sequence, D. The DNA sequence is connected as follows: GTTCAGT" /></p>

<p>With that in mind, here‚Äôs your first milestone:
<strong>Milestone 1: Implement Core Functions</strong></p>
<ol>
  <li>Add at two custom test cases to SplicingAndDicing.cpp, one for each of the functions mentioned above.</li>
  <li>Implement the deleteNucleotides function and test it thoroughly.</li>
  <li>Implement the fromDNA function and test it thoroughly.</li>
</ol>

<p>Some notes on this problem:</p>
<ul>
  <li><strong>Draw pictures!</strong> Get out a pencil and paper and trace out what operations you want to perform on your linked lists before you write any code. Then, as you‚Äôre writing up the code, refer back to your pictures to make sure each line of code does what you want it to do.</li>
  <li><strong>These functions must not be implemented recursively.</strong> We‚Äôre going to run some large DNA strands through your code, and you won‚Äôt have enough stack space to proceed recursively.</li>
  <li>You <strong>must not</strong> use any of the container types (e.g. Vector, Set, etc.) in the your solutions. See if you can do this purely using linked lists.</li>
  <li>If you leave a pointer uninitialized in C++, it does not default to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code> and instead points somewhere random. Using a pointer like this will almost certainly crash your program immediately. It‚Äôs a good idea to explicitly set pointers you don‚Äôt want pointing at anything to nullptr.</li>
  <li>Your implementations of these functions should run in time O(n). If you‚Äôre able to pass the provided stress tests, with each one taking at most a few seconds, you should be in good shape.</li>
  <li>You can assume these functions always take in a pointer to the first nucleotide in the strand (or nullptr if the strand is empty). You don‚Äôt need to handle pointers into the middle of lists.</li>
  <li>You should not allocate any memory with new in the course of implementing these functions, since you‚Äôre not actually creating any new nucleotides. Feel free to declare variables of type Nucleotide* (remember that creating a pointer is separate from requesting space using the new operator), but don‚Äôt use the new operator.</li>
</ul>

<h3 id="milestone-two-construct-new-sequences">Milestone Two: Construct New Sequences</h3>
<p>Your next task is to write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nucleotide</span><span class="o">*</span> <span class="nf">toStrand</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">dna</span><span class="p">);</span>
</code></pre></div></div>
<p>This function takes in a string representing a DNA strand and returns a chain of <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code>s encoding that DNA strand. You can think of it as the inverse of the <code class="language-c++ highlighter-rouge"><span class="n">fromDNA</span></code> function: <code class="language-c++ highlighter-rouge"><span class="n">fromDNA</span></code> takes in a Nucleotide* and returns a <code class="language-c++ highlighter-rouge"><span class="n">string</span></code>, while <code class="language-c++ highlighter-rouge"><span class="n">toStrand</span></code> takes in a <code class="language-c++ highlighter-rouge"><span class="n">string</span></code> and returns a <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span><span class="o">*</span></code>.
For example, calling <code class="language-c++ highlighter-rouge"><span class="n">toStrand</span><span class="p">(</span><span class="s">"TAGCAT"</span><span class="p">)</span></code> should return the a pointer to the first nucleotide in the DNA strand shown below:
<img src="img/DNA_3.png" alt="The DNA sequence is connected as follows: TAGCAT" /></p>

<p>Here‚Äôs what you need to do:</p>

<p><strong>Milestone 2: Construct New Sequences</strong></p>
<ol>
  <li>Add a custom test case to SplicingAndDicing.cpp to test the toStrand function.</li>
  <li>Implement toStrand and test it thoroughly.</li>
</ol>

<p>Some notes on this problem:</p>
<ul>
  <li><strong><em>Draw pictures!</em></strong> Get out a pencil and paper and trace out what operations you want to perform on your linked lists before you write any code. Then, as you‚Äôre writing up the code, refer back to your pictures to make sure each line of code does what you want it to do.</li>
  <li><strong><em>These functions must not be implemented recursively</em></strong>. We‚Äôre going to run some large DNA strands through your code, and you won‚Äôt have enough stack space to proceed recursively.</li>
  <li>You <strong><em>must not</em></strong> use any of the container types (e.g. <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code>, etc.) in the your solutions. See if you can do this purely using linked lists.</li>
  <li>Remember that the linked list you produce should be a doubly-linked list. This will require you to do some extra wiring in your <code class="language-c++ highlighter-rouge"><span class="n">toStrand</span></code> function.</li>
  <li>Don‚Äôt be afraid to set breakpoints in test cases and pull up the debugger if you need to figure out where a crash comes from or why your code isn‚Äôt working. After working through the labyrinth exercises, you should have all the tools you need to reconstruct the state of memory on a sheet of paper. More generally, we recommend that you <em>never</em> run your program using the regular ‚Äúrun‚Äù button and <em>always</em> run with the debugger turned on so that if anything bad happens, you can poke around and see where things went wrong.</li>
  <li>Your implementation of this function should run in time O(<em>n</em>). If you‚Äôre able to pass the provided stress tests, with each one taking at most a few seconds, you should be in good shape.</li>
  <li>Although we‚Äôre writing this code in the context of DNA sequences where each character is one of <code class="language-c++ highlighter-rouge"><span class="sc">'A'</span></code>, <code class="language-c++ highlighter-rouge"><span class="sc">'C'</span></code>, <code class="language-c++ highlighter-rouge"><span class="sc">'G'</span></code>, or <code class="language-c++ highlighter-rouge"><span class="sc">'T'</span></code>, your code should be general enough to work on strings containing other characters.</li>
</ul>

<h3 id="milestone-three-implement-searching">Milestone Three: Implement Searching</h3>
<p>Your next task is to implement a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nucleotide</span><span class="o">*</span> <span class="nf">findFirst</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*</span> <span class="n">dna</span><span class="p">,</span> <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">target</span><span class="p">);</span>
</code></pre></div></div>
<p>that searches for a copy of the strand given by <code class="language-c++ highlighter-rouge"><span class="n">target</span></code> inside the strand given by <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>, then returns a pointer to the first cell in the match. For example, given these DNA strands, <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code> should return a pointer to the third nucleotide in the dna list.
<img src="img/DNA_4.png" alt="There are 2 strands of DNA. The pointer dna points to the first strand, which is as follows: GTCAGTCAGT. The target pointer points to the second strand, which is: CAG." />
(As before, we aren‚Äôt drawing the <code class="language-c++ highlighter-rouge"><span class="n">null</span></code> pointers that appear as the <code class="language-c++ highlighter-rouge"><span class="n">next</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointers of the first and last elements of the DNA strands.)
If the sequence given by <code class="language-c++ highlighter-rouge"><span class="n">target</span></code> doesn‚Äôt appear in <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>, this function should return <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code> to indicate that the sequence wasn‚Äôt found.
Here‚Äôs the requirements for this milestone:
<strong>Milestone 3: Implement Searching</strong></p>
<ol>
  <li>Add at least one custom test case to <code class="language-c++ highlighter-rouge"><span class="n">SplicingAndDicing</span><span class="p">.</span><span class="n">cpp</span></code> for <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code>.</li>
  <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code> function and test it thoroughly.</li>
</ol>

<p>Some notes on this problem:</p>
<ul>
  <li><strong>Draw pictures!</strong> Get out a pencil and paper and trace out what operations you want to perform on your linked lists before you write any code. Then, as you‚Äôre writing up the code, refer back to your pictures to make sure each line of code does what you want it to do.</li>
  <li>You <strong>must not</strong> use any of the container types (e.g. Vector, Set, etc.) in the course of solving this problem. See if you can do this purely using linked lists.</li>
  <li>You <strong>must not</strong> use the string type in your implementation. Write this one purely using linked lists.</li>
  <li>The <code class="language-c++ highlighter-rouge"><span class="n">target</span></code> sequence could be empty, in which case this function should report that target appears at the start of <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>. This is similar to what you‚Äôd do if you wanted to search for the empty string inside of another string: it always exists, and it‚Äôs always at the front.</li>
  <li>You can assume the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects that make up the target sequence are different objects than the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects that make up <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>. That is, the target pointer doesn‚Äôt point into the middle of <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>. More generally, you can assume the pointers passed into this function always point at the start of the lists in question.</li>
  <li>You should not allocate any memory with <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> in the course of implementing <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code>, since you‚Äôre not actually creating any new nucleotides. Feel free to declare variables of type <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span><span class="o">*</span></code> (remember that creating a pointer is separate from using the <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> keyword), but don‚Äôt use the <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> operator.</li>
  <li>Your code should be efficient enough to pass the test cases that we‚Äôve bundled with the starter files, but aside from that we won‚Äôt set any specific big-O target runtime.</li>
  <li>Although we‚Äôre writing this code in the context of DNA sequences where each character is one of <code class="language-c++ highlighter-rouge"><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="sc">'G'</span><span class="p">,</span> <span class="n">or</span> <span class="sc">'T'</span></code>, your code should be general enough to work on strings containing other characters.</li>
</ul>

<h3 id="milestone-four-implement-splicing">Milestone Four: Implement Splicing</h3>
<p>Your last task is to write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">spliceFirst</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*&amp;</span> <span class="n">dna</span><span class="p">,</span> <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">target</span><span class="p">);</span>
</code></pre></div></div>
<p>that takes as input two DNA strands. The first strand, <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>, is the DNA sequence to search. The second strand, <code class="language-c++ highlighter-rouge"><span class="n">target</span></code>, is a specific sequence to chop out of the DNA strand. Your function should then find the first copy of <code class="language-c++ highlighter-rouge"><span class="n">target</span></code> inside of <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>, then edit the <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> strand by removing that sequence in its entirety. If that sequence doesn‚Äôt exist, this function should return false to indicate that nothing was removed.
For example, suppose we have these strands:
<img src="img/DNA_5.png" alt="There are 2 strands of DNA. The pointer dna points to the first strand, which is as follows: GTCAGTCAGT. The target pointer points to the second strand, which is: CAG." />
As before, we aren‚Äôt drawing the <code class="language-c++ highlighter-rouge"><span class="n">null</span></code> pointers that appear as the <code class="language-c++ highlighter-rouge"><span class="n">next</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointers of the first and last elements of the DNA strands. Calling <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></code> would give this result:
<img src="img/DNA_6.png" alt="There are 2 strands of DNA. The pointer dna points to the first strand, which is as follows: GTTCAGT. The target pointer points to the second strand, which is: CAG." /></p>

<p>The first copy of <code class="language-c++ highlighter-rouge"><span class="s">"CAG"</span></code> was deleted from <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>, though the second copy of <code class="language-c++ highlighter-rouge"><span class="s">"CAG"</span></code> still exists; <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> only removes the first copy of <code class="language-c++ highlighter-rouge"><span class="n">target</span></code>. On the other hand, suppose we have these sequences:
<img src="img/DNA_7.png" alt="There are 2 strands of DNA. The pointer dna points to the first strand, which is as follows: GTTCAGT. The target pointer points to the second strand, which is: GT." />
Calling <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></code> would result in the following:
<img src="img/DNA_8.png" alt="There are 2 strands of DNA. The pointer dna points to the first strand, which is as follows: TCAGT. The target pointer points to the second strand, which is: GT." />
Notice that dna has changed to point later in the sequence, since we deleted the beginning of the strand.
Given this, here‚Äôs your next milestone:</p>

<p><strong>Given this, here‚Äôs your next milestone:</strong></p>
<ol>
  <li>Add at least one custom test for the <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> function.</li>
  <li>Implement the <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> function and test it thoroughly.</li>
</ol>

<p>Some notes on this problem:</p>
<ul>
  <li><strong>Draw pictures!</strong> Get out a pencil and paper and trace out what operations you want to perform on your linked lists before you write any code. Then, as you‚Äôre writing up the code, refer back to your pictures to make sure each line of code does what you want it to do.</li>
  <li>You <strong>must not</strong> use any of the container types (e.g. Vector, Set, etc.) in the course of solving this problem. See if you can do this purely using linked lists.</li>
  <li>You <strong>must not</strong> use the string type in your implementation. Write this one purely using linked lists.</li>
  <li>As before, you should not implement this function recursively because we might be running huge DNA sequences through it and you won‚Äôt have the stack space to pull this off.</li>
  <li>Your function should leave the original strand unchanged except for the removed section and possibly the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotides</span></code> that appear just before and just after that section. In other words, you should only make local modifications to the strand rather than, say, allocating a new strand or changing which characters are stored in which <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects.</li>
  <li>You can assume that <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects that make up the target sequence are different objects than the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects that make up <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>. That is, the target pointer doesn‚Äôt point into the middle of <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>.</li>
  <li>Your implementation of <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> should not leak any memory. In particular, if you remove any nucleotides from the DNA strand, you should be sure to delete them.</li>
  <li>You may have noticed that the <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> parameter is passed by reference (i.e. <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span><span class="o">*&amp;</span></code> rather than <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span><span class="o">*</span></code>). This is because you may need to change where the <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> pointer points; specifically, if you remove the first nucleotide from the strand, you will need to reassign <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> to point after the removed sequence. Be careful not to change where <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code> is pointing unless you‚Äôre removing something from the front of the sequence.</li>
  <li>The <code class="language-c++ highlighter-rouge"><span class="n">target</span></code> sequence could be empty, in which case this function should simulate removing nothing from the DNA strand. Specifically, your function should leave the DNA strand unmodified and return true to indicate that, indeed, zero nucleotides were removed from it.</li>
  <li>You should not allocate any memory using <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> in the course of implementing spliceFirst, since you‚Äôre not actually creating any new nucleotides. Feel free to declare variables of type <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span><span class="o">*</span></code> (remember that creating a pointer is separate from allocating memory using <code class="language-c++ highlighter-rouge"><span class="k">new</span></code>), but don‚Äôt use the <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> operator.</li>
  <li>If, in the course of coding this one up, you start seeing crashes or bugs in <code class="language-c++ highlighter-rouge"><span class="n">fromDNA</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">deleteNucleotides</span></code>, or <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code>, it could mean either that there‚Äôs a bug in your <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> function that caused the list to be wired improperly or that there was a lurking issue in one of those earlier functions that accidentally sneaked past the tests from the earlier milestones. In other words, don‚Äôt immediately assume that one of the earlier functions is the culprit; investigate <code class="language-c++ highlighter-rouge"><span class="n">spliceFirst</span></code> as well to make sure that it didn‚Äôt leave the wiring between the nucleotides in a bad state.</li>
  <li><strong>The debugger is your friend!</strong> Don‚Äôt hesitate to set breakpoints in test cases or step through your code if you find any issues with your program; this is a <em>great</em> way to see what your code is doing. You learned how to sketch out how linked structures look in memory when working through the labyrinth escape, and those same skills will be useful to you here.</li>
  <li>Your code should be efficient enough to pass the test cases that we‚Äôve bundled with the starter files, but aside from that we won‚Äôt set any specific big-O target runtime.</li>
  <li>Although we‚Äôre writing this code in the context of DNA sequences where each character is one of <code class="language-c++ highlighter-rouge"><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="sc">'G'</span><span class="p">,</span> <span class="n">or</span> <span class="sc">'T'</span></code>, your code should be general enough to work on strings containing other characters.</li>
</ul>

<p><strong>(Optional) Problem Three: Extensions</strong>
This assignment is all about linked structures, and there‚Äôs plenty of room for you to do Fun and Exciting Things with the topics we‚Äôve covered here. Here‚Äôs some thoughts to help get you started, but the sky‚Äôs the limit here!</p>
<ul>
  <li><strong>The Labyrinth!:</strong> Our provided code generates random mazes using combinations of several famous algorithms and data structures. (The normal maze is generated using Kruskal‚Äôs algorithm and a disjoint-set forest, the twisted maze is generated using an ErdoÃãs‚ÄìReÃÅnyi random graph with connectivity guaranteed via breadth-first search, and the starting locations are chosen by a procedure that uses the Floyd-Warshall algorithm as substep.) There are lots of fairly accessible articles online about how to generate random mazes in other ways. For example, you can use a randomized depth-first search to build mazes with lots of long, twisted hallways, or randomized Prim‚Äôs algorithm to build mazes that branch out from a central location. Wilson‚Äôs algorithm produces mazes that are sampled uniformly at random from the space of all possible mazes. Play around with these and see what you find!</li>
</ul>

<p>Other things you could consider: could you build a visualizer that draws the maze given a pointer to your starting location? Or could you write a program that automatically finds the shortest paths out of a maze?</p>
<ul>
  <li><strong>Splicing and Dicing:</strong> DNA often comes in the form of plasmids, in which the DNA links in a ring rather than having a definitive beginning and end. Adapt the functions you wrote earlier to work in the case where the input strands are plasmids in addition to regular DNA strands.</li>
</ul>

<p>There are a number of algorithms you can use to implement <code class="language-c++ highlighter-rouge"><span class="n">findFirst</span></code> in time O(m + n), where m is the length of the DNA strand / plasmid to process and n is the length of the target sequence. (This is as fast as you can make this algorithm ‚Äì anything shorter than this means that you can‚Äôt even read the whole DNA sequence and target, something you‚Äôd need to do in the worst case). The Knuth-Morris-Pratt (KMP) algorithm guarantees this worst-case performance. The Rabin-Karp algorithm uses hash functions in a really clever way that gives an average-case performance of O(m + n), though with a worst-case performance of O(mn). Explore these algorithms and see what you find!</p>

<p>You‚Äôre working on a bunch of routines for manipulating DNA sequences, and there‚Äôs plenty of in- teresting work you could do with this. Could you simulate the process by which the Pfizer-BioN- Tech mRNA vaccine was made? Could you simulate how CRISPR-Cas9 works?</p>
<h2 id="submission-instructions">Submission Instructions</h2>
<p>Once you‚Äôve autoindented your code so that it looks beautiful and worked through the Assignment Sub- mission Checklist, submit the following files on Paperless, plus any other files you modified when writing up extensions:</p>
<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">Labyrinth</span><span class="p">.</span><span class="n">cpp</span><span class="p">.</span></code></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">LabyrinthEscape</span><span class="p">.</span><span class="n">cpp</span><span class="p">.</span></code></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">SplicingAndDicing</span><span class="p">.</span><span class="n">cpp</span><span class="p">.</span></code></li>
</ul>

<p>And that‚Äôs it! You‚Äôre done! You‚Äôve gotten comfortable working with linked structures and are now much more comfortable working with the debugger. Nicely done!</p>

<p><strong>Good luck, and have fun!</strong></p>

</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2020 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2021-Mar-08
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
